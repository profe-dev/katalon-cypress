/* tslint:disable */
/* eslint-disable */
/**
 * Katalon TestOps API reference
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AgentConfigResource
 */
export interface AgentConfigResource {
    /**
     * 
     * @type {string}
     * @memberof AgentConfigResource
     */
    teamId?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfigResource
     */
    agentName?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfigResource
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfigResource
     */
    os?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentConfigResource
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface AgentResource
 */
export interface AgentResource {
    /**
     * 
     * @type {number}
     * @memberof AgentResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    lastPing?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    os?: string;
    /**
     * 
     * @type {number}
     * @memberof AgentResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    hostname?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AgentResource
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AgentResource
     */
    threshold?: number;
    /**
     * 
     * @type {number}
     * @memberof AgentResource
     */
    numExecutingJobs?: number;
    /**
     * 
     * @type {number}
     * @memberof AgentResource
     */
    numAssignedJobs?: number;
    /**
     * 
     * @type {string}
     * @memberof AgentResource
     */
    agentVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AgentResource
     */
    deleted?: boolean;
}
/**
 * 
 * @export
 * @interface BuildInfo
 */
export interface BuildInfo {
    /**
     * 
     * @type {number}
     * @memberof BuildInfo
     */
    build_num?: number;
    /**
     * 
     * @type {number}
     * @memberof BuildInfo
     */
    job_id?: number;
    /**
     * 
     * @type {number}
     * @memberof BuildInfo
     */
    build_time_millis?: number;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    usage_queued_at?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildInfo
     */
    stop_time?: string;
    /**
     * 
     * @type {Array<BuildLog>}
     * @memberof BuildInfo
     */
    steps?: Array<BuildLog>;
}
/**
 * 
 * @export
 * @interface BuildLog
 */
export interface BuildLog {
    /**
     * 
     * @type {string}
     * @memberof BuildLog
     */
    logFileUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildLog
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildLog
     */
    name?: string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BuildLog
     */
    actions?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface CircleCIAgentResource
 */
export interface CircleCIAgentResource {
    /**
     * 
     * @type {number}
     * @memberof CircleCIAgentResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    vcsType?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    branch?: string;
    /**
     * 
     * @type {number}
     * @memberof CircleCIAgentResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof CircleCIAgentResource
     */
    apiKey?: string;
}
/**
 * 
 * @export
 * @interface CircleCIConnectionResource
 */
export interface CircleCIConnectionResource {
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    vcsType?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIConnectionResource
     */
    branch?: string;
}
/**
 * 
 * @export
 * @interface CircleCIProject
 */
export interface CircleCIProject {
    /**
     * 
     * @type {string}
     * @memberof CircleCIProject
     */
    username?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CircleCIProject
     */
    branches?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof CircleCIProject
     */
    reponame?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIProject
     */
    vcs_url?: string;
    /**
     * 
     * @type {string}
     * @memberof CircleCIProject
     */
    vcs_type?: string;
}
/**
 * 
 * @export
 * @interface CommentResource
 */
export interface CommentResource {
    /**
     * 
     * @type {number}
     * @memberof CommentResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentResource
     */
    objectId?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentResource
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CommentResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    objectType?: CommentResourceObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentResource
     */
    displayAvatar?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommentResource
     */
    bySystem?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum CommentResourceObjectTypeEnum {
    ExecutionTestSuite = 'EXECUTION_TEST_SUITE',
    ExecutionTestResult = 'EXECUTION_TEST_RESULT',
    TestCase = 'TEST_CASE',
    Incident = 'INCIDENT',
    KeyesExecution = 'KEYES_EXECUTION'
}

/**
 * 
 * @export
 * @interface ConfigResource
 */
export interface ConfigResource {
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    webSocketUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    storeUrl?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigResource
     */
    profiles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    stripePublicApi?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    buildVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    commitId?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    sentryDsn?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    sentryEnv?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    serverUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    ioServerUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigResource
     */
    maxExecutionComparison?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigResource
     */
    maxExecutionDownload?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConfigResource
     */
    agentDownloadUrls?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    reportUploaderDownloadUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    reportUploaderLatestVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    subDomainPattern?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResource
     */
    cancellationSurveyUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResource
     */
    advancedFeatureEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResource
     */
    usingSubDomain?: boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentVariable
 */
export interface EnvironmentVariable {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentVariable
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ExecutionRequestResource
 */
export interface ExecutionRequestResource {
    /**
     * 
     * @type {number}
     * @memberof ExecutionRequestResource
     */
    id?: number;
    /**
     * 
     * @type {ExecutionTestResultResource}
     * @memberof ExecutionRequestResource
     */
    executionTestResult?: ExecutionTestResultResource;
    /**
     * 
     * @type {TestObjectResource}
     * @memberof ExecutionRequestResource
     */
    object?: TestObjectResource;
    /**
     * 
     * @type {number}
     * @memberof ExecutionRequestResource
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutionRequestResource
     */
    abnormal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExecutionRequestResource
     */
    percentAbnormal?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionRequestResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionRequestResource
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionRequestResource
     */
    statusText?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionRequestResource
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionRequestResource
     */
    size?: number;
    /**
     * 
     * @type {UploadFileResource}
     * @memberof ExecutionRequestResource
     */
    uploadFile?: UploadFileResource;
    /**
     * 
     * @type {string}
     * @memberof ExecutionRequestResource
     */
    startedAt?: string;
}
/**
 * 
 * @export
 * @interface ExecutionResource
 */
export interface ExecutionResource {
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    status?: ExecutionResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    elapsedDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalDiffTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalDiffPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalDiffFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalDiffErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    totalDiffIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    projectId?: number;
    /**
     * 
     * @type {ProjectResource}
     * @memberof ExecutionResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    buildId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionResource
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    executionStage?: ExecutionResourceExecutionStageEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    webUrl?: string;
    /**
     * 
     * @type {Array<TestSuiteCollectionEntityResource>}
     * @memberof ExecutionResource
     */
    testSuiteCollections?: Array<TestSuiteCollectionEntityResource>;
    /**
     * 
     * @type {Array<ExecutionTestSuiteResource>}
     * @memberof ExecutionResource
     */
    executionTestSuiteResources?: Array<ExecutionTestSuiteResource>;
    /**
     * 
     * @type {ReleaseResource}
     * @memberof ExecutionResource
     */
    release?: ReleaseResource;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutionResource
     */
    hasComment?: boolean;
    /**
     * 
     * @type {UserResource}
     * @memberof ExecutionResource
     */
    user?: UserResource;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    sessionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    buildLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    buildUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionResource
     */
    type?: ExecutionResourceTypeEnum;
    /**
     * 
     * @type {Array<JobResource>}
     * @memberof ExecutionResource
     */
    jobs?: Array<JobResource>;
}

/**
    * @export
    * @enum {string}
    */
export enum ExecutionResourceStatusEnum {
    Passed = 'PASSED',
    Failed = 'FAILED',
    Error = 'ERROR',
    Incomplete = 'INCOMPLETE',
    Running = 'RUNNING',
    Skipped = 'SKIPPED',
    NotRun = 'NOT_RUN'
}
/**
    * @export
    * @enum {string}
    */
export enum ExecutionResourceExecutionStageEnum {
    Running = 'RUNNING',
    Completed = 'COMPLETED',
    Terminate = 'TERMINATE',
    Analyzing = 'ANALYZING',
    Analyzed = 'ANALYZED',
    Importing = 'IMPORTING',
    Error = 'ERROR'
}
/**
    * @export
    * @enum {string}
    */
export enum ExecutionResourceTypeEnum {
    Katalon = 'KATALON',
    Bdd = 'BDD'
}

/**
 * 
 * @export
 * @interface ExecutionShareReportResource
 */
export interface ExecutionShareReportResource {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExecutionShareReportResource
     */
    emails?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ExecutionShareReportResource
     */
    executionId?: number;
}
/**
 * 
 * @export
 * @interface ExecutionTestCaseResource
 */
export interface ExecutionTestCaseResource {
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestCaseResource
     */
    status?: ExecutionTestCaseResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestCaseResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestCaseResource
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    elapsedDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalDiffTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalDiffPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalDiffFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalDiffErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    totalDiffIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    executionId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    executionOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    testCaseId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestCaseResource
     */
    projectId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ExecutionTestCaseResourceStatusEnum {
    Passed = 'PASSED',
    Failed = 'FAILED',
    Error = 'ERROR',
    Incomplete = 'INCOMPLETE',
    Running = 'RUNNING',
    Skipped = 'SKIPPED',
    NotRun = 'NOT_RUN'
}

/**
 * 
 * @export
 * @interface ExecutionTestResultIdentifyResource
 */
export interface ExecutionTestResultIdentifyResource {
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultIdentifyResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultIdentifyResource
     */
    executionId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultIdentifyResource
     */
    urlId?: string;
}
/**
 * 
 * @export
 * @interface ExecutionTestResultResource
 */
export interface ExecutionTestResultResource {
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    id?: number;
    /**
     * 
     * @type {TestCaseResource}
     * @memberof ExecutionTestResultResource
     */
    testCase?: TestCaseResource;
    /**
     * 
     * @type {ExecutionResource}
     * @memberof ExecutionTestResultResource
     */
    execution?: ExecutionResource;
    /**
     * 
     * @type {PlatformResource}
     * @memberof ExecutionTestResultResource
     */
    platform?: PlatformResource;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    status?: ExecutionTestResultResourceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    sameStatusPeriod?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    errorDetailsId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    stdoutId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    descriptionId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    logId?: number;
    /**
     * 
     * @type {Array<FileResource>}
     * @memberof ExecutionTestResultResource
     */
    attachments?: Array<FileResource>;
    /**
     * 
     * @type {Array<TestResultAssertionFailedResource>}
     * @memberof ExecutionTestResultResource
     */
    testResultAssertionsFailed?: Array<TestResultAssertionFailedResource>;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    duration?: number;
    /**
     * 
     * @type {Array<ExecutionTestResultIdentifyResource>}
     * @memberof ExecutionTestResultResource
     */
    sameFailureResults?: Array<ExecutionTestResultIdentifyResource>;
    /**
     * 
     * @type {TestSuiteResource}
     * @memberof ExecutionTestResultResource
     */
    testSuite?: TestSuiteResource;
    /**
     * 
     * @type {ExecutionTestSuiteResource}
     * @memberof ExecutionTestResultResource
     */
    executionTestSuite?: ExecutionTestSuiteResource;
    /**
     * 
     * @type {Array<IncidentResource>}
     * @memberof ExecutionTestResultResource
     */
    incidents?: Array<IncidentResource>;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    profile?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutionTestResultResource
     */
    hasComment?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    errorMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    errorDetail?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    webUrl?: string;
    /**
     * 
     * @type {Array<ExternalIssueResource>}
     * @memberof ExecutionTestResultResource
     */
    externalIssues?: Array<ExternalIssueResource>;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    failedTestResultCategory?: ExecutionTestResultResourceFailedTestResultCategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    totalTestObject?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    totalDefects?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    totalAssertion?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    passedAssertion?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestResultResource
     */
    failedAssertion?: number;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestResultResource
     */
    urlId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ExecutionTestResultResourceStatusEnum {
    Passed = 'PASSED',
    Failed = 'FAILED',
    Error = 'ERROR',
    Incomplete = 'INCOMPLETE',
    Running = 'RUNNING',
    Skipped = 'SKIPPED',
    NotRun = 'NOT_RUN'
}
/**
    * @export
    * @enum {string}
    */
export enum ExecutionTestResultResourceFailedTestResultCategoryEnum {
    Application = 'APPLICATION',
    Automation = 'AUTOMATION',
    Environment = 'ENVIRONMENT',
    Unknown = 'UNKNOWN'
}

/**
 * 
 * @export
 * @interface ExecutionTestSuiteResource
 */
export interface ExecutionTestSuiteResource {
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestSuiteResource
     */
    status?: ExecutionTestSuiteResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestSuiteResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestSuiteResource
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    elapsedDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalDiffTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalDiffPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalDiffFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalDiffErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    totalDiffIncompleteTests?: number;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    id?: number;
    /**
     * 
     * @type {ExecutionResource}
     * @memberof ExecutionTestSuiteResource
     */
    execution?: ExecutionResource;
    /**
     * 
     * @type {TestSuiteResource}
     * @memberof ExecutionTestSuiteResource
     */
    testSuite?: TestSuiteResource;
    /**
     * 
     * @type {PlatformResource}
     * @memberof ExecutionTestSuiteResource
     */
    platform?: PlatformResource;
    /**
     * 
     * @type {number}
     * @memberof ExecutionTestSuiteResource
     */
    executionId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExecutionTestSuiteResource
     */
    profiles?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ExecutionTestSuiteResource
     */
    hasComment?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTestSuiteResource
     */
    urlId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ExecutionTestSuiteResourceStatusEnum {
    Passed = 'PASSED',
    Failed = 'FAILED',
    Error = 'ERROR',
    Incomplete = 'INCOMPLETE',
    Running = 'RUNNING',
    Skipped = 'SKIPPED',
    NotRun = 'NOT_RUN'
}

/**
 * 
 * @export
 * @interface ExternalIssueResource
 */
export interface ExternalIssueResource {
    /**
     * 
     * @type {number}
     * @memberof ExternalIssueResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    issueId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    issueTypeIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    issueTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalIssueResource
     */
    featureName?: string;
    /**
     * 
     * @type {Array<TestCaseResource>}
     * @memberof ExternalIssueResource
     */
    testCases?: Array<TestCaseResource>;
    /**
     * 
     * @type {Array<ExecutionTestResultResource>}
     * @memberof ExternalIssueResource
     */
    testResults?: Array<ExecutionTestResultResource>;
}
/**
 * 
 * @export
 * @interface ExternalProjectResource
 */
export interface ExternalProjectResource {
    /**
     * 
     * @type {number}
     * @memberof ExternalProjectResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExternalProjectResource
     */
    externalProjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalProjectResource
     */
    externalProjectKey?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalProjectResource
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ExternalReleaseResource
 */
export interface ExternalReleaseResource {
    /**
     * 
     * @type {number}
     * @memberof ExternalReleaseResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExternalReleaseResource
     */
    releaseId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalReleaseResource
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalReleaseResource
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalReleaseResource
     */
    archived?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalReleaseResource
     */
    released?: boolean;
    /**
     * 
     * @type {ExternalProjectResource}
     * @memberof ExternalReleaseResource
     */
    externalProject?: ExternalProjectResource;
    /**
     * 
     * @type {string}
     * @memberof ExternalReleaseResource
     */
    webUrl?: string;
}
/**
 * 
 * @export
 * @interface FileResource
 */
export interface FileResource {
    /**
     * 
     * @type {number}
     * @memberof FileResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    hash?: string;
    /**
     * 
     * @type {number}
     * @memberof FileResource
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    uploadUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof FileResource
     */
    signedUrl?: string;
}
/**
 * 
 * @export
 * @interface GitRepositoryResource
 */
export interface GitRepositoryResource {
    /**
     * 
     * @type {number}
     * @memberof GitRepositoryResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GitRepositoryResource
     */
    testProjectId?: number;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    repository?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    branch?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    password?: string;
    /**
     * 
     * @type {number}
     * @memberof GitRepositoryResource
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof GitRepositoryResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GitRepositoryResource
     */
    vcsType?: GitRepositoryResourceVcsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GitRepositoryResourceVcsTypeEnum {
    Github = 'GITHUB',
    Gitlab = 'GITLAB',
    Bitbucket = 'BITBUCKET',
    Others = 'OTHERS'
}

/**
 * 
 * @export
 * @interface IncidentExecutionTestResultResource
 */
export interface IncidentExecutionTestResultResource {
    /**
     * 
     * @type {number}
     * @memberof IncidentExecutionTestResultResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof IncidentExecutionTestResultResource
     */
    incidentId?: number;
    /**
     * 
     * @type {number}
     * @memberof IncidentExecutionTestResultResource
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof IncidentExecutionTestResultResource
     */
    incidentOrder?: number;
    /**
     * 
     * @type {number}
     * @memberof IncidentExecutionTestResultResource
     */
    executionTestResultId?: number;
}
/**
 * 
 * @export
 * @interface IncidentResource
 */
export interface IncidentResource {
    /**
     * 
     * @type {number}
     * @memberof IncidentResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof IncidentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentResource
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof IncidentResource
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof IncidentResource
     */
    teamId?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof IncidentResource
     */
    urlIds?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IncidentResource
     */
    executionTestResultIds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof IncidentResource
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof IncidentResource
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentResource
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface JobResource
 */
export interface JobResource {
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    buildNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    status?: JobResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    queuedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    stopTime?: string;
    /**
     * 
     * @type {TestProjectResource}
     * @memberof JobResource
     */
    testProject?: TestProjectResource;
    /**
     * 
     * @type {ExecutionResource}
     * @memberof JobResource
     */
    execution?: ExecutionResource;
    /**
     * 
     * @type {AgentResource}
     * @memberof JobResource
     */
    agent?: AgentResource;
    /**
     * 
     * @type {K8SAgentResource}
     * @memberof JobResource
     */
    k8sAgent?: K8SAgentResource;
    /**
     * 
     * @type {CircleCIAgentResource}
     * @memberof JobResource
     */
    circleCiAgent?: CircleCIAgentResource;
    /**
     * 
     * @type {RunConfigurationResource}
     * @memberof JobResource
     */
    runConfiguration?: RunConfigurationResource;
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    order?: number;
    /**
     * 
     * @type {TriggerBuildParameter}
     * @memberof JobResource
     */
    parameter?: TriggerBuildParameter;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    triggerBy?: JobResourceTriggerByEnum;
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    triggerAt?: string;
    /**
     * 
     * @type {UserResource}
     * @memberof JobResource
     */
    user?: UserResource;
    /**
     * 
     * @type {SchedulerResource}
     * @memberof JobResource
     */
    scheduler?: SchedulerResource;
    /**
     * 
     * @type {ProjectResource}
     * @memberof JobResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    processId?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResource
     */
    nodeStatus?: JobResourceNodeStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof JobResource
     */
    runConfigurationId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum JobResourceStatusEnum {
    Queued = 'QUEUED',
    Running = 'RUNNING',
    Failed = 'FAILED',
    Success = 'SUCCESS',
    Canceled = 'CANCELED',
    Error = 'ERROR',
    WaitForTrigger = 'WAIT_FOR_TRIGGER'
}
/**
    * @export
    * @enum {string}
    */
export enum JobResourceTriggerByEnum {
    Manual = 'MANUAL',
    Schedule = 'SCHEDULE'
}
/**
    * @export
    * @enum {string}
    */
export enum JobResourceNodeStatusEnum {
    PendingCanceled = 'PENDING_CANCELED',
    Canceled = 'CANCELED'
}

/**
 * 
 * @export
 * @interface K8SAgentResource
 */
export interface K8SAgentResource {
    /**
     * 
     * @type {number}
     * @memberof K8SAgentResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    certificateAuthority?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    cluster?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    accessKey?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    privateAccessKey?: string;
    /**
     * 
     * @type {number}
     * @memberof K8SAgentResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof K8SAgentResource
     */
    authenticationType?: K8SAgentResourceAuthenticationTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum K8SAgentResourceAuthenticationTypeEnum {
    BasicAuth = 'BASIC_AUTH',
    BearerToken = 'BEARER_TOKEN',
    EksAuth = 'EKS_AUTH'
}

/**
 * 
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    hour?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    minute?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    second?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    nano?: number;
}
/**
 * 
 * @export
 * @interface OrganizationFeatureFlagResource
 */
export interface OrganizationFeatureFlagResource {
    /**
     * 
     * @type {number}
     * @memberof OrganizationFeatureFlagResource
     */
    organizationId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationFeatureFlagResource
     */
    subDomain?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationFeatureFlagResource
     */
    strictDomain?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationFeatureFlagResource
     */
    sso?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationFeatureFlagResource
     * @deprecated
     */
    circleCi?: boolean;
}
/**
 * 
 * @export
 * @interface OrganizationResource
 */
export interface OrganizationResource {
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    role?: OrganizationResourceRoleEnum;
    /**
     * 
     * @type {OrganizationFeatureFlagResource}
     * @memberof OrganizationResource
     */
    orgFeatureFlag?: OrganizationFeatureFlagResource;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    quotaKSE?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    machineQuotaKSE?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    quotaEngine?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    machineQuotaEngine?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    usedKSE?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    usedEngine?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    quotaTestOps?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    usedTestOps?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    numberUser?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    quotaFloatingEngine?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    usedFloatingEngine?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    canCreateOfflineKSE?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    canCreateOfflineRE?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    subscriptionExpiryDateEngine?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    subscriptionExpiryDateKSE?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    subscriptionExpiryDateFloatingEngine?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    subscriptionExpiryDateTestOps?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    subscribed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    ksePaygo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    krePaygo?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrganizationResource
     */
    paygoQuota?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    subdomainUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    strictDomain?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    logoUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    samlSSO?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationResource
     */
    kreLicense?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    testOpsPackage?: OrganizationResourceTestOpsPackageEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResource
     */
    mostRecentProjectAccessedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationResourceRoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    User = 'USER',
    BillingManager = 'BILLING_MANAGER'
}
/**
    * @export
    * @enum {string}
    */
export enum OrganizationResourceTestOpsPackageEnum {
    Basic = 'BASIC',
    Advanced = 'ADVANCED',
    Enterprise = 'ENTERPRISE'
}

/**
 * 
 * @export
 * @interface OrganizationTrialRequestResource
 */
export interface OrganizationTrialRequestResource {
    /**
     * 
     * @type {OrganizationResource}
     * @memberof OrganizationTrialRequestResource
     */
    organization?: OrganizationResource;
    /**
     * 
     * @type {UserResource}
     * @memberof OrganizationTrialRequestResource
     */
    userRequest?: UserResource;
    /**
     * 
     * @type {string}
     * @memberof OrganizationTrialRequestResource
     */
    status?: OrganizationTrialRequestResourceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationTrialRequestResource
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationTrialRequestResource
     */
    formRequest?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationTrialRequestResourceStatusEnum {
    Pending = 'PENDING',
    Approved = 'APPROVED',
    Rejected = 'REJECTED'
}

/**
 * 
 * @export
 * @interface PageBaseResource
 */
export interface PageBaseResource {
    /**
     * 
     * @type {number}
     * @memberof PageBaseResource
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageBaseResource
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageBaseResource
     */
    size?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageBaseResource
     */
    content?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof PageBaseResource
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageBaseResource
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageBaseResource
     */
    numberOfElements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageBaseResource
     */
    first?: boolean;
    /**
     * 
     * @type {Pageable}
     * @memberof PageBaseResource
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageBaseResource
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageBaseResource
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageExecutionResource
 */
export interface PageExecutionResource {
    /**
     * 
     * @type {number}
     * @memberof PageExecutionResource
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageExecutionResource
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageExecutionResource
     */
    size?: number;
    /**
     * 
     * @type {Array<ExecutionResource>}
     * @memberof PageExecutionResource
     */
    content?: Array<ExecutionResource>;
    /**
     * 
     * @type {number}
     * @memberof PageExecutionResource
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageExecutionResource
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageExecutionResource
     */
    numberOfElements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageExecutionResource
     */
    first?: boolean;
    /**
     * 
     * @type {Pageable}
     * @memberof PageExecutionResource
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageExecutionResource
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageExecutionResource
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageJobResource
 */
export interface PageJobResource {
    /**
     * 
     * @type {number}
     * @memberof PageJobResource
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageJobResource
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageJobResource
     */
    size?: number;
    /**
     * 
     * @type {Array<JobResource>}
     * @memberof PageJobResource
     */
    content?: Array<JobResource>;
    /**
     * 
     * @type {number}
     * @memberof PageJobResource
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageJobResource
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageJobResource
     */
    numberOfElements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageJobResource
     */
    first?: boolean;
    /**
     * 
     * @type {Pageable}
     * @memberof PageJobResource
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageJobResource
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageJobResource
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageProjectResource
 */
export interface PageProjectResource {
    /**
     * 
     * @type {number}
     * @memberof PageProjectResource
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProjectResource
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageProjectResource
     */
    size?: number;
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof PageProjectResource
     */
    content?: Array<ProjectResource>;
    /**
     * 
     * @type {number}
     * @memberof PageProjectResource
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageProjectResource
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageProjectResource
     */
    numberOfElements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageProjectResource
     */
    first?: boolean;
    /**
     * 
     * @type {Pageable}
     * @memberof PageProjectResource
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageProjectResource
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageProjectResource
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface PageTeamResource
 */
export interface PageTeamResource {
    /**
     * 
     * @type {number}
     * @memberof PageTeamResource
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageTeamResource
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageTeamResource
     */
    size?: number;
    /**
     * 
     * @type {Array<TeamResource>}
     * @memberof PageTeamResource
     */
    content?: Array<TeamResource>;
    /**
     * 
     * @type {number}
     * @memberof PageTeamResource
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageTeamResource
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageTeamResource
     */
    numberOfElements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageTeamResource
     */
    first?: boolean;
    /**
     * 
     * @type {Pageable}
     * @memberof PageTeamResource
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageTeamResource
     */
    last?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageTeamResource
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface PlatformResource
 */
export interface PlatformResource {
    /**
     * 
     * @type {number}
     * @memberof PlatformResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformResource
     */
    osName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformResource
     */
    osVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformResource
     */
    browserName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformResource
     */
    browserVersion?: string;
}
/**
 * 
 * @export
 * @interface ProjectConfigurationResource
 */
export interface ProjectConfigurationResource {
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigurationResource
     */
    name?: ProjectConfigurationResourceNameEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfigurationResource
     */
    value?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectConfigurationResourceNameEnum {
    Timezone = 'TIMEZONE',
    AssertionPattern = 'ASSERTION_PATTERN'
}

/**
 * 
 * @export
 * @interface ProjectResource
 */
export interface ProjectResource {
    /**
     * 
     * @type {number}
     * @memberof ProjectResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectResource
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectResource
     */
    teamId?: number;
    /**
     * 
     * @type {TeamResource}
     * @memberof ProjectResource
     */
    team?: TeamResource;
    /**
     * 
     * @type {string}
     * @memberof ProjectResource
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResource
     */
    status?: ProjectResourceStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectResourceStatusEnum {
    Archive = 'ARCHIVE',
    Active = 'ACTIVE'
}

/**
 * 
 * @export
 * @interface ProjectSettingResource
 */
export interface ProjectSettingResource {
    /**
     * 
     * @type {number}
     * @memberof ProjectSettingResource
     */
    projectId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSettingResource
     */
    bdd?: boolean;
}
/**
 * 
 * @export
 * @interface ReleaseResource
 */
export interface ReleaseResource {
    /**
     * 
     * @type {number}
     * @memberof ReleaseResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReleaseResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseResource
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseResource
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ReleaseResource
     */
    projectId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseResource
     */
    closed?: boolean;
    /**
     * 
     * @type {ExternalReleaseResource}
     * @memberof ReleaseResource
     */
    externalRelease?: ExternalReleaseResource;
    /**
     * 
     * @type {ReleaseStatisticsResource}
     * @memberof ReleaseResource
     */
    releaseStatistics?: ReleaseStatisticsResource;
}
/**
 * 
 * @export
 * @interface ReleaseStatisticsResource
 */
export interface ReleaseStatisticsResource {
    /**
     * 
     * @type {number}
     * @memberof ReleaseStatisticsResource
     */
    id?: number;
    /**
     * 
     * @type {ReleaseResource}
     * @memberof ReleaseStatisticsResource
     */
    release?: ReleaseResource;
    /**
     * 
     * @type {number}
     * @memberof ReleaseStatisticsResource
     */
    totalPassed?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseStatisticsResource
     */
    totalFailed?: number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseStatisticsResource
     */
    totalExecution?: number;
}
/**
 * 
 * @export
 * @interface RunConfigurationResource
 */
export interface RunConfigurationResource {
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    command?: string;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    teamId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    testProjectId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    releaseId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    testSuiteCollectionId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunConfigurationResource
     */
    timeOut?: number;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    configType?: RunConfigurationResourceConfigTypeEnum;
    /**
     * 
     * @type {TestProjectResource}
     * @memberof RunConfigurationResource
     */
    testProject?: TestProjectResource;
    /**
     * 
     * @type {Array<AgentResource>}
     * @memberof RunConfigurationResource
     */
    agents?: Array<AgentResource>;
    /**
     * 
     * @type {Array<K8SAgentResource>}
     * @memberof RunConfigurationResource
     */
    k8sAgents?: Array<K8SAgentResource>;
    /**
     * 
     * @type {Array<CircleCIAgentResource>}
     * @memberof RunConfigurationResource
     */
    circleCIAgents?: Array<CircleCIAgentResource>;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    cloudType?: RunConfigurationResourceCloudTypeEnum;
    /**
     * 
     * @type {JobResource}
     * @memberof RunConfigurationResource
     */
    latestJob?: JobResource;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    genericCommand?: string;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    ksVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof RunConfigurationResource
     */
    ksLocation?: string;
    /**
     * 
     * @type {SchedulerResource}
     * @memberof RunConfigurationResource
     */
    nextRunScheduler?: SchedulerResource;
    /**
     * 
     * @type {ReleaseResource}
     * @memberof RunConfigurationResource
     */
    release?: ReleaseResource;
}

/**
    * @export
    * @enum {string}
    */
export enum RunConfigurationResourceConfigTypeEnum {
    Tsc = 'TSC',
    Command = 'COMMAND',
    GenericCommand = 'GENERIC_COMMAND'
}
/**
    * @export
    * @enum {string}
    */
export enum RunConfigurationResourceCloudTypeEnum {
    K8S = 'K8S',
    LocalAgent = 'LOCAL_AGENT',
    K8SAgent = 'K8S_AGENT',
    CircleCiAgent = 'CIRCLE_CI_AGENT'
}

/**
 * 
 * @export
 * @interface SchedulerResource
 */
export interface SchedulerResource {
    /**
     * 
     * @type {number}
     * @memberof SchedulerResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SchedulerResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SchedulerResource
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SchedulerResource
     */
    nextTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SchedulerResource
     */
    endTime?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SchedulerResource
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SchedulerResource
     */
    interval?: number;
    /**
     * 
     * @type {string}
     * @memberof SchedulerResource
     */
    intervalUnit?: SchedulerResourceIntervalUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof SchedulerResource
     */
    runConfigurationId?: number;
    /**
     * 
     * @type {RunConfigurationResource}
     * @memberof SchedulerResource
     */
    runConfiguration?: RunConfigurationResource;
}

/**
    * @export
    * @enum {string}
    */
export enum SchedulerResourceIntervalUnitEnum {
    Minute = 'MINUTE',
    Hour = 'HOUR',
    Day = 'DAY',
    Week = 'WEEK',
    Month = 'MONTH'
}

/**
 * 
 * @export
 * @interface SearchConfigResource
 */
export interface SearchConfigResource {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SearchConfigResource
     */
    filterConfig?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchConfigResource
     */
    sortDefault?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchConfigResource
     */
    sortConfig?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {Array<SearchRequestCondition>}
     * @memberof SearchRequest
     */
    searchRequestConditions?: Array<SearchRequestCondition>;
    /**
     * 
     * @type {SearchRequestPagination}
     * @memberof SearchRequest
     */
    searchRequestPagination?: SearchRequestPagination;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchRequest
     */
    searchRequestGroupBys?: Array<string>;
    /**
     * 
     * @type {Array<SearchRequestFunction>}
     * @memberof SearchRequest
     */
    searchRequestFunctions?: Array<SearchRequestFunction>;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    searchEntity?: SearchRequestSearchEntityEnum;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    timeZone?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SearchRequestSearchEntityEnum {
    Execution = 'Execution',
    ExecutionTestSuite = 'ExecutionTestSuite',
    ExecutionStatistics = 'ExecutionStatistics',
    ExecutionTestModule = 'ExecutionTestModule',
    ExecutionTestResult = 'ExecutionTestResult',
    ExecutionRequest = 'ExecutionRequest',
    Incident = 'Incident',
    TestCase = 'TestCase',
    TestSuite = 'TestSuite',
    ExecutionTestStep = 'ExecutionTestStep',
    TestProject = 'TestProject',
    Job = 'Job',
    RunningTestRun = 'RunningTestRun',
    Project = 'Project',
    ApiKey = 'ApiKey',
    Comment = 'Comment',
    Team = 'Team',
    Organization = 'Organization',
    UserOrganization = 'UserOrganization',
    UserTeam = 'UserTeam',
    UserInvitation = 'UserInvitation',
    UserSsoInvitation = 'UserSsoInvitation',
    UserConfiguration = 'UserConfiguration',
    Agent = 'Agent',
    RunConfiguration = 'RunConfiguration',
    Release = 'Release',
    TestObject = 'TestObject',
    TestObjectEntity = 'TestObjectEntity',
    TestCaseExecution = 'TestCaseExecution',
    TestCaseExecutionStatus = 'TestCaseExecutionStatus',
    ReleaseStatisticsStatus = 'ReleaseStatisticsStatus',
    TestCaseExecutionComparison = 'TestCaseExecutionComparison',
    TestCaseExecutionComparisonStatistics = 'TestCaseExecutionComparisonStatistics',
    TestCasePlatformStatistics = 'TestCasePlatformStatistics',
    Scheduler = 'Scheduler',
    ExecutionAnalysis = 'ExecutionAnalysis',
    ExecutionTestResultCategory = 'ExecutionTestResultCategory',
    ExecutionTestResultGroup = 'ExecutionTestResultGroup',
    ExecutionTestResultTestObjectEntity = 'ExecutionTestResultTestObjectEntity',
    ExecutionFile = 'ExecutionFile',
    TestSuiteCollection = 'TestSuiteCollection',
    TestSuiteCollectionEntity = 'TestSuiteCollectionEntity',
    TestCasePriority = 'TestCasePriority',
    ExternalConnection = 'ExternalConnection',
    PlatformStatistics = 'PlatformStatistics',
    TestProjectFile = 'TestProjectFile',
    ProjectStatistics = 'ProjectStatistics',
    ProjectRequirementStatistic = 'ProjectRequirementStatistic',
    TestCaseRequirementStatistic = 'TestCaseRequirementStatistic',
    UserOrganizationFeature = 'UserOrganizationFeature',
    Machine = 'Machine',
    LicenseKey = 'LicenseKey',
    K8SAgent = 'K8SAgent',
    CircleCiAgent = 'CircleCiAgent',
    JobSummary = 'JobSummary',
    KatalonRecorderBackup = 'KatalonRecorderBackup',
    ExternalDefect = 'ExternalDefect',
    ExternalRequirement = 'ExternalRequirement',
    ExternalTraceability = 'ExternalTraceability',
    RequirementTestRunCoverage = 'RequirementTestRunCoverage',
    WhitelistIp = 'WhitelistIp',
    KsSession = 'KsSession',
    CiDashboardStatistics = 'CiDashboardStatistics',
    Checkpoint = 'Checkpoint',
    KeyesExecution = 'KeyesExecution',
    RecentProject = 'RecentProject',
    JiraIssue = 'JiraIssue',
    SlackConnection = 'SlackConnection',
    Baseline = 'Baseline',
    BaselineCollection = 'BaselineCollection',
    TestCaseFlakiness = 'TestCaseFlakiness'
}

/**
 * 
 * @export
 * @interface SearchRequestCondition
 */
export interface SearchRequestCondition {
    /**
     * 
     * @type {string}
     * @memberof SearchRequestCondition
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequestCondition
     */
    operator?: string;
    /**
     * 
     * @type {object}
     * @memberof SearchRequestCondition
     */
    value?: object;
}
/**
 * 
 * @export
 * @interface SearchRequestFunction
 */
export interface SearchRequestFunction {
    /**
     * 
     * @type {string}
     * @memberof SearchRequestFunction
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequestFunction
     */
    functionName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchRequestFunction
     */
    parameters?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SearchRequestFunction
     */
    timeZone?: string;
}
/**
 * 
 * @export
 * @interface SearchRequestPagination
 */
export interface SearchRequestPagination {
    /**
     * 
     * @type {number}
     * @memberof SearchRequestPagination
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchRequestPagination
     */
    size?: number;
    /**
     * 
     * @type {Array<SearchRequestSortOrder>}
     * @memberof SearchRequestPagination
     */
    sorts?: Array<SearchRequestSortOrder>;
}
/**
 * 
 * @export
 * @interface SearchRequestSortOrder
 */
export interface SearchRequestSortOrder {
    /**
     * 
     * @type {string}
     * @memberof SearchRequestSortOrder
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequestSortOrder
     */
    order?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface TeamResource
 */
export interface TeamResource {
    /**
     * 
     * @type {number}
     * @memberof TeamResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamResource
     */
    role?: TeamResourceRoleEnum;
    /**
     * 
     * @type {Array<UserResource>}
     * @memberof TeamResource
     */
    users?: Array<UserResource>;
    /**
     * 
     * @type {OrganizationResource}
     * @memberof TeamResource
     */
    organization?: OrganizationResource;
    /**
     * 
     * @type {number}
     * @memberof TeamResource
     */
    organizationId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum TeamResourceRoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    User = 'USER'
}

/**
 * 
 * @export
 * @interface TestCasePlatformStatisticsResource
 */
export interface TestCasePlatformStatisticsResource {
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    totalTests?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    totalPassedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    totalFailedTests?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    totalErrorTests?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    totalIncompleteTests?: number;
    /**
     * 
     * @type {PlatformResource}
     * @memberof TestCasePlatformStatisticsResource
     */
    platform?: PlatformResource;
    /**
     * 
     * @type {number}
     * @memberof TestCasePlatformStatisticsResource
     */
    platformId?: number;
}
/**
 * 
 * @export
 * @interface TestCaseResource
 */
export interface TestCaseResource {
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    previousStatus?: TestCaseResourcePreviousStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    alias?: string;
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    testModuleId?: number;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    webUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    description?: string;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestCaseResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {ExecutionTestCaseResource}
     * @memberof TestCaseResource
     */
    lastExecutionTestCase?: ExecutionTestCaseResource;
    /**
     * 
     * @type {Array<ExternalIssueResource>}
     * @memberof TestCaseResource
     */
    externalIssues?: Array<ExternalIssueResource>;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    type?: TestCaseResourceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    averageDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    maxDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    minDuration?: number;
    /**
     * 
     * @type {Array<ExecutionTestResultResource>}
     * @memberof TestCaseResource
     */
    executionTestResults?: Array<ExecutionTestResultResource>;
    /**
     * 
     * @type {number}
     * @memberof TestCaseResource
     */
    flakiness?: number;
    /**
     * 
     * @type {{ [key: string]: TestCasePlatformStatisticsResource; }}
     * @memberof TestCaseResource
     */
    platformStatistics?: { [key: string]: TestCasePlatformStatisticsResource; };
    /**
     * 
     * @type {UserResource}
     * @memberof TestCaseResource
     */
    maintainer?: UserResource;
    /**
     * 
     * @type {TestResultAssertionResource}
     * @memberof TestCaseResource
     */
    testResultAssertion?: TestResultAssertionResource;
    /**
     * 
     * @type {string}
     * @memberof TestCaseResource
     */
    urlId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TestCaseResourcePreviousStatusEnum {
    Passed = 'PASSED',
    Failed = 'FAILED',
    Error = 'ERROR',
    Incomplete = 'INCOMPLETE',
    Running = 'RUNNING',
    Skipped = 'SKIPPED',
    NotRun = 'NOT_RUN'
}
/**
    * @export
    * @enum {string}
    */
export enum TestCaseResourceTypeEnum {
    TestCase = 'TEST_CASE',
    Scenario = 'SCENARIO'
}

/**
 * 
 * @export
 * @interface TestObjectEntityResource
 */
export interface TestObjectEntityResource {
    /**
     * 
     * @type {number}
     * @memberof TestObjectEntityResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestObjectEntityResource
     */
    name?: string;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestObjectEntityResource
     */
    project?: ProjectResource;
}
/**
 * 
 * @export
 * @interface TestObjectResource
 */
export interface TestObjectResource {
    /**
     * 
     * @type {number}
     * @memberof TestObjectResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestObjectResource
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof TestObjectResource
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof TestObjectResource
     */
    averageDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof TestObjectResource
     */
    maxDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof TestObjectResource
     */
    minDuration?: number;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestObjectResource
     */
    project?: ProjectResource;
}
/**
 * 
 * @export
 * @interface TestProjectResource
 */
export interface TestProjectResource {
    /**
     * 
     * @type {number}
     * @memberof TestProjectResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestProjectResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestProjectResource
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof TestProjectResource
     */
    uploadFileId?: number;
    /**
     * 
     * @type {number}
     * @memberof TestProjectResource
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof TestProjectResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof TestProjectResource
     */
    createdAt?: string;
    /**
     * 
     * @type {JobResource}
     * @memberof TestProjectResource
     */
    latestJob?: JobResource;
    /**
     * 
     * @type {string}
     * @memberof TestProjectResource
     */
    uploadFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof TestProjectResource
     */
    type?: TestProjectResourceTypeEnum;
    /**
     * 
     * @type {GitRepositoryResource}
     * @memberof TestProjectResource
     */
    gitRepository?: GitRepositoryResource;
    /**
     * 
     * @type {Array<TestSuiteCollectionResource>}
     * @memberof TestProjectResource
     */
    testSuiteCollections?: Array<TestSuiteCollectionResource>;
}

/**
    * @export
    * @enum {string}
    */
export enum TestProjectResourceTypeEnum {
    Ks = 'KS',
    Git = 'GIT'
}

/**
 * 
 * @export
 * @interface TestResultAssertionFailedResource
 */
export interface TestResultAssertionFailedResource {
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionFailedResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionFailedResource
     */
    executionTestResultId?: number;
    /**
     * 
     * @type {ExecutionTestResultResource}
     * @memberof TestResultAssertionFailedResource
     */
    executionTestResultResource?: ExecutionTestResultResource;
    /**
     * 
     * @type {string}
     * @memberof TestResultAssertionFailedResource
     */
    stacktrace?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultAssertionFailedResource
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResultAssertionFailedResource
     */
    logTime?: string;
}
/**
 * 
 * @export
 * @interface TestResultAssertionResource
 */
export interface TestResultAssertionResource {
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionResource
     */
    executionTestResultId?: number;
    /**
     * 
     * @type {ExecutionTestResultResource}
     * @memberof TestResultAssertionResource
     */
    executionTestResult?: ExecutionTestResultResource;
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionResource
     */
    totalAssertion?: number;
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionResource
     */
    passedAssertion?: number;
    /**
     * 
     * @type {number}
     * @memberof TestResultAssertionResource
     */
    failedAssertion?: number;
}
/**
 * 
 * @export
 * @interface TestRunResult
 */
export interface TestRunResult {
    /**
     * 
     * @type {string}
     * @memberof TestRunResult
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestRunResult
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof TestRunResult
     */
    sessionId?: string;
    /**
     * 
     * @type {string}
     * @memberof TestRunResult
     */
    testSuiteId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TestRunResult
     */
    end?: boolean;
}
/**
 * 
 * @export
 * @interface TestSuiteCollectionEntityResource
 */
export interface TestSuiteCollectionEntityResource {
    /**
     * 
     * @type {number}
     * @memberof TestSuiteCollectionEntityResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteCollectionEntityResource
     */
    name?: string;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestSuiteCollectionEntityResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteCollectionEntityResource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteCollectionEntityResource
     */
    urlId?: string;
}
/**
 * 
 * @export
 * @interface TestSuiteCollectionResource
 */
export interface TestSuiteCollectionResource {
    /**
     * 
     * @type {number}
     * @memberof TestSuiteCollectionResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteCollectionResource
     */
    name?: string;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestSuiteCollectionResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteCollectionResource
     */
    urlId?: string;
}
/**
 * 
 * @export
 * @interface TestSuiteResource
 */
export interface TestSuiteResource {
    /**
     * 
     * @type {number}
     * @memberof TestSuiteResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteResource
     */
    path?: string;
    /**
     * 
     * @type {ProjectResource}
     * @memberof TestSuiteResource
     */
    project?: ProjectResource;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteResource
     */
    alias?: string;
    /**
     * 
     * @type {ExecutionTestSuiteResource}
     * @memberof TestSuiteResource
     */
    lastExecutionTestSuite?: ExecutionTestSuiteResource;
    /**
     * 
     * @type {string}
     * @memberof TestSuiteResource
     */
    urlId?: string;
}
/**
 * 
 * @export
 * @interface TimeZoneResource
 */
export interface TimeZoneResource {
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResource
     */
    zoneId?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResource
     */
    name?: string;
    /**
     * 
     * @type {TimeZoneResourceOffset}
     * @memberof TimeZoneResource
     */
    offset?: TimeZoneResourceOffset;
}
/**
 * 
 * @export
 * @interface TimeZoneResourceOffset
 */
export interface TimeZoneResourceOffset {
    /**
     * 
     * @type {number}
     * @memberof TimeZoneResourceOffset
     */
    totalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffset
     */
    id?: string;
    /**
     * 
     * @type {TimeZoneResourceOffsetRules}
     * @memberof TimeZoneResourceOffset
     */
    rules?: TimeZoneResourceOffsetRules;
}
/**
 * 
 * @export
 * @interface TimeZoneResourceOffsetRules
 */
export interface TimeZoneResourceOffsetRules {
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRules
     */
    fixedOffset?: boolean;
    /**
     * 
     * @type {Array<TimeZoneResourceOffsetRulesTransitions>}
     * @memberof TimeZoneResourceOffsetRules
     */
    transitions?: Array<TimeZoneResourceOffsetRulesTransitions>;
    /**
     * 
     * @type {Array<TimeZoneResourceOffsetRulesTransitionRules>}
     * @memberof TimeZoneResourceOffsetRules
     */
    transitionRules?: Array<TimeZoneResourceOffsetRulesTransitionRules>;
}
/**
 * 
 * @export
 * @interface TimeZoneResourceOffsetRulesDuration
 */
export interface TimeZoneResourceOffsetRulesDuration {
    /**
     * 
     * @type {number}
     * @memberof TimeZoneResourceOffsetRulesDuration
     */
    seconds?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeZoneResourceOffsetRulesDuration
     */
    nano?: number;
    /**
     * 
     * @type {Array<TimeZoneResourceOffsetRulesDurationUnits>}
     * @memberof TimeZoneResourceOffsetRulesDuration
     */
    units?: Array<TimeZoneResourceOffsetRulesDurationUnits>;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesDuration
     */
    zero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesDuration
     */
    negative?: boolean;
}
/**
 * 
 * @export
 * @interface TimeZoneResourceOffsetRulesDurationUnits
 */
export interface TimeZoneResourceOffsetRulesDurationUnits {
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesDurationUnits
     */
    dateBased?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesDurationUnits
     */
    timeBased?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesDurationUnits
     */
    durationEstimated?: boolean;
}
/**
 * 
 * @export
 * @interface TimeZoneResourceOffsetRulesTransitionRules
 */
export interface TimeZoneResourceOffsetRulesTransitionRules {
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    month?: TimeZoneResourceOffsetRulesTransitionRulesMonthEnum;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    timeDefinition?: TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    dayOfWeek?: TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum;
    /**
     * 
     * @type {number}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    dayOfMonthIndicator?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    midnightEndOfDay?: boolean;
    /**
     * 
     * @type {LocalTime}
     * @memberof TimeZoneResourceOffsetRulesTransitionRules
     */
    localTime?: LocalTime;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeZoneResourceOffsetRulesTransitionRulesMonthEnum {
    January = 'JANUARY',
    February = 'FEBRUARY',
    March = 'MARCH',
    April = 'APRIL',
    May = 'MAY',
    June = 'JUNE',
    July = 'JULY',
    August = 'AUGUST',
    September = 'SEPTEMBER',
    October = 'OCTOBER',
    November = 'NOVEMBER',
    December = 'DECEMBER'
}
/**
    * @export
    * @enum {string}
    */
export enum TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum {
    Utc = 'UTC',
    Wall = 'WALL',
    Standard = 'STANDARD'
}
/**
    * @export
    * @enum {string}
    */
export enum TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum {
    Monday = 'MONDAY',
    Tuesday = 'TUESDAY',
    Wednesday = 'WEDNESDAY',
    Thursday = 'THURSDAY',
    Friday = 'FRIDAY',
    Saturday = 'SATURDAY',
    Sunday = 'SUNDAY'
}

/**
 * 
 * @export
 * @interface TimeZoneResourceOffsetRulesTransitions
 */
export interface TimeZoneResourceOffsetRulesTransitions {
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    instant?: string;
    /**
     * 
     * @type {TimeZoneResourceOffsetRulesDuration}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    duration?: TimeZoneResourceOffsetRulesDuration;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    gap?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    overlap?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    dateTimeAfter?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeZoneResourceOffsetRulesTransitions
     */
    dateTimeBefore?: string;
}
/**
 * 
 * @export
 * @interface TriggerBuildParameter
 */
export interface TriggerBuildParameter {
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    downloadUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    command?: string;
    /**
     * 
     * @type {Array<EnvironmentVariable>}
     * @memberof TriggerBuildParameter
     */
    environmentVariables?: Array<EnvironmentVariable>;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    sessionId?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    ksVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    ksLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    configType?: TriggerBuildParameterConfigTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TriggerBuildParameter
     */
    type?: TriggerBuildParameterTypeEnum;
    /**
     * 
     * @type {GitRepositoryResource}
     * @memberof TriggerBuildParameter
     */
    gitRepositoryResource?: GitRepositoryResource;
}

/**
    * @export
    * @enum {string}
    */
export enum TriggerBuildParameterConfigTypeEnum {
    Tsc = 'TSC',
    Command = 'COMMAND',
    GenericCommand = 'GENERIC_COMMAND'
}
/**
    * @export
    * @enum {string}
    */
export enum TriggerBuildParameterTypeEnum {
    Ks = 'KS',
    Git = 'GIT'
}

/**
 * 
 * @export
 * @interface UploadBatchFileResource
 */
export interface UploadBatchFileResource {
    /**
     * 
     * @type {string}
     * @memberof UploadBatchFileResource
     */
    folderPath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadBatchFileResource
     */
    end?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UploadBatchFileResource
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadBatchFileResource
     */
    uploadedPath?: string;
}
/**
 * 
 * @export
 * @interface UploadBatchResource
 */
export interface UploadBatchResource {
    /**
     * 
     * @type {number}
     * @memberof UploadBatchResource
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UploadBatchResource
     */
    done?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UploadBatchResource
     */
    webUrl?: string;
}
/**
 * 
 * @export
 * @interface UploadFileResource
 */
export interface UploadFileResource {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResource
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResource
     */
    type?: UploadFileResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResource
     */
    base64Content?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadFileResource
     */
    fileHandleId?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum UploadFileResourceTypeEnum {
    TscExecution = 'TSC_EXECUTION',
    TsExecution = 'TS_EXECUTION',
    Attachment = 'ATTACHMENT',
    Properties = 'PROPERTIES',
    Har = 'HAR',
    Uuid = 'UUID',
    Zip = 'ZIP',
    Bdd = 'BDD',
    TestopsReportMetadata = 'TESTOPS_REPORT_METADATA',
    TestopsReportExecution = 'TESTOPS_REPORT_EXECUTION',
    TestopsReportSuites = 'TESTOPS_REPORT_SUITES',
    TestopsReportResults = 'TESTOPS_REPORT_RESULTS'
}

/**
 * 
 * @export
 * @interface UserOrganizationFeatureResource
 */
export interface UserOrganizationFeatureResource {
    /**
     * 
     * @type {UserResource}
     * @memberof UserOrganizationFeatureResource
     */
    user?: UserResource;
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationFeatureResource
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationFeatureResource
     */
    organizationId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationFeatureResource
     */
    userEmail?: string;
    /**
     * 
     * @type {OrganizationResource}
     * @memberof UserOrganizationFeatureResource
     */
    organization?: OrganizationResource;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationFeatureResource
     */
    feature?: UserOrganizationFeatureResourceFeatureEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserOrganizationFeatureResourceFeatureEnum {
    Kse = 'KSE',
    Engine = 'ENGINE',
    Testops = 'TESTOPS',
    FloatingEngine = 'FLOATING_ENGINE',
    UnlimitedKse = 'UNLIMITED_KSE',
    UnlimitedEngine = 'UNLIMITED_ENGINE'
}

/**
 * 
 * @export
 * @interface UserResource
 */
export interface UserResource {
    /**
     * 
     * @type {number}
     * @memberof UserResource
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    invitingUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    avatar?: string;
    /**
     * 
     * @type {ConfigResource}
     * @memberof UserResource
     */
    configs?: ConfigResource;
    /**
     * 
     * @type {Array<ProjectResource>}
     * @memberof UserResource
     */
    projects?: Array<ProjectResource>;
    /**
     * 
     * @type {Array<TeamResource>}
     * @memberof UserResource
     */
    teams?: Array<TeamResource>;
    /**
     * 
     * @type {Array<OrganizationResource>}
     * @memberof UserResource
     */
    organizations?: Array<OrganizationResource>;
    /**
     * 
     * @type {Array<UserOrganizationFeatureResource>}
     * @memberof UserResource
     */
    organizationFeature?: Array<UserOrganizationFeatureResource>;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    trialExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    systemRole?: UserResourceSystemRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserResource
     */
    businessUser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResource
     */
    canCreateOfflineKSE?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResource
     */
    canCreateOfflineRE?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResource
     */
    samlSSO?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResource
     */
    fullName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserResourceSystemRoleEnum {
    User = 'USER',
    KatalonAdmin = 'KATALON_ADMIN'
}

/**
 * 
 * @export
 * @interface UserSettingResource
 */
export interface UserSettingResource {
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingResource
     */
    mailJobStart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingResource
     */
    mailJobEnd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingResource
     */
    mailExecution?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettingResource
     */
    mailExecutionStatus?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingResource
     */
    mailWeeklyUpdate?: boolean;
}
/**
 * 
 * @export
 * @interface UserTeamResource
 */
export interface UserTeamResource {
    /**
     * 
     * @type {number}
     * @memberof UserTeamResource
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTeamResource
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTeamResource
     */
    teamId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserTeamResource
     */
    role?: UserTeamResourceRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserTeamResourceRoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    User = 'USER'
}


/**
 * AgentApi - axios parameter creator
 * @export
 */
export const AgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/v1/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (agentResource: AgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentResource' is not null or undefined
            if (agentResource === null || agentResource === undefined) {
                throw new RequiredError('agentResource','Required parameter agentResource was null or undefined when calling create.');
            }
            const localVarPath = `/api/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof agentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(agentResource !== undefined ? agentResource : {})
                : (agentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (circleCIAgentResource: CircleCIAgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'circleCIAgentResource' is not null or undefined
            if (circleCIAgentResource === null || circleCIAgentResource === undefined) {
                throw new RequiredError('circleCIAgentResource','Required parameter circleCIAgentResource was null or undefined when calling create4.');
            }
            const localVarPath = `/api/v1/circle-ci-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof circleCIAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(circleCIAgentResource !== undefined ? circleCIAgentResource : {})
                : (circleCIAgentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: async (k8SAgentResource: K8SAgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8SAgentResource' is not null or undefined
            if (k8SAgentResource === null || k8SAgentResource === undefined) {
                throw new RequiredError('k8SAgentResource','Required parameter k8SAgentResource was null or undefined when calling create5.');
            }
            const localVarPath = `/api/v1/k8s-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof k8SAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(k8SAgentResource !== undefined ? k8SAgentResource : {})
                : (k8SAgentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAgent: async (agentConfigResource: AgentConfigResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentConfigResource' is not null or undefined
            if (agentConfigResource === null || agentConfigResource === undefined) {
                throw new RequiredError('agentConfigResource','Required parameter agentConfigResource was null or undefined when calling generateAgent.');
            }
            const localVarPath = `/api/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (agentConfigResource !== undefined) {
                localVarQueryParameter['agentConfigResource'] = agentConfigResource;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/api/v1/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a CircleCI agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get11: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get11.');
            }
            const localVarPath = `/api/v1/circle-ci-agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a K8S agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get13: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get13.');
            }
            const localVarPath = `/api/v1/k8s-agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircleCIConnectionResource} circleCIConnectionResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedProjects: async (circleCIConnectionResource: CircleCIConnectionResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'circleCIConnectionResource' is not null or undefined
            if (circleCIConnectionResource === null || circleCIConnectionResource === undefined) {
                throw new RequiredError('circleCIConnectionResource','Required parameter circleCIConnectionResource was null or undefined when calling getFollowedProjects.');
            }
            const localVarPath = `/api/v1/circle-ci-agent/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof circleCIConnectionResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(circleCIConnectionResource !== undefined ? circleCIConnectionResource : {})
                : (circleCIConnectionResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6: async (circleCIAgentResource: CircleCIAgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'circleCIAgentResource' is not null or undefined
            if (circleCIAgentResource === null || circleCIAgentResource === undefined) {
                throw new RequiredError('circleCIAgentResource','Required parameter circleCIAgentResource was null or undefined when calling update6.');
            }
            const localVarPath = `/api/v1/circle-ci-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof circleCIAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(circleCIAgentResource !== undefined ? circleCIAgentResource : {})
                : (circleCIAgentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7: async (k8SAgentResource: K8SAgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8SAgentResource' is not null or undefined
            if (k8SAgentResource === null || k8SAgentResource === undefined) {
                throw new RequiredError('k8SAgentResource','Required parameter k8SAgentResource was null or undefined when calling update7.');
            }
            const localVarPath = `/api/v1/k8s-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof k8SAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(k8SAgentResource !== undefined ? k8SAgentResource : {})
                : (k8SAgentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThreshold: async (agentResource: AgentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentResource' is not null or undefined
            if (agentResource === null || agentResource === undefined) {
                throw new RequiredError('agentResource','Required parameter agentResource was null or undefined when calling updateThreshold.');
            }
            const localVarPath = `/api/v1/agent/threshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof agentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(agentResource !== undefined ? agentResource : {})
                : (agentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentApi - functional programming interface
 * @export
 */
export const AgentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration)._delete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(agentResource: AgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).create(agentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(circleCIAgentResource: CircleCIAgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircleCIAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).create4(circleCIAgentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create5(k8SAgentResource: K8SAgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<K8SAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).create5(k8SAgentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAgent(agentConfigResource: AgentConfigResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).generateAgent(agentConfigResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).get(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a CircleCI agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get11(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircleCIAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).get11(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a K8S agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get13(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<K8SAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).get13(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CircleCIConnectionResource} circleCIConnectionResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowedProjects(circleCIConnectionResource: CircleCIConnectionResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CircleCIProject>>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).getFollowedProjects(circleCIConnectionResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update6(circleCIAgentResource: CircleCIAgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircleCIAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).update6(circleCIAgentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update7(k8SAgentResource: K8SAgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<K8SAgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).update7(k8SAgentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateThreshold(agentResource: AgentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResource>> {
            const localVarAxiosArgs = await AgentApiAxiosParamCreator(configuration).updateThreshold(agentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AgentApi - factory interface
 * @export
 */
export const AgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): AxiosPromise<AgentResource> {
            return AgentApiFp(configuration)._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(agentResource: AgentResource, options?: any): AxiosPromise<AgentResource> {
            return AgentApiFp(configuration).create(agentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(circleCIAgentResource: CircleCIAgentResource, options?: any): AxiosPromise<CircleCIAgentResource> {
            return AgentApiFp(configuration).create4(circleCIAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(k8SAgentResource: K8SAgentResource, options?: any): AxiosPromise<K8SAgentResource> {
            return AgentApiFp(configuration).create5(k8SAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAgent(agentConfigResource: AgentConfigResource, options?: any): AxiosPromise<void> {
            return AgentApiFp(configuration).generateAgent(agentConfigResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id: number, options?: any): AxiosPromise<AgentResource> {
            return AgentApiFp(configuration).get(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a CircleCI agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get11(id: number, options?: any): AxiosPromise<CircleCIAgentResource> {
            return AgentApiFp(configuration).get11(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a K8S agent detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get13(id: number, options?: any): AxiosPromise<K8SAgentResource> {
            return AgentApiFp(configuration).get13(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircleCIConnectionResource} circleCIConnectionResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedProjects(circleCIConnectionResource: CircleCIConnectionResource, options?: any): AxiosPromise<Array<CircleCIProject>> {
            return AgentApiFp(configuration).getFollowedProjects(circleCIConnectionResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6(circleCIAgentResource: CircleCIAgentResource, options?: any): AxiosPromise<CircleCIAgentResource> {
            return AgentApiFp(configuration).update6(circleCIAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7(k8SAgentResource: K8SAgentResource, options?: any): AxiosPromise<K8SAgentResource> {
            return AgentApiFp(configuration).update7(k8SAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThreshold(agentResource: AgentResource, options?: any): AxiosPromise<AgentResource> {
            return AgentApiFp(configuration).updateThreshold(agentResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentApi - object-oriented interface
 * @export
 * @class AgentApi
 * @extends {BaseAPI}
 */
export class AgentApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a Local agent. Returns the deleted agent detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public _delete(id: number, options?: any) {
        return AgentApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates or updates a Local agent. Returns the agent detail.
     * @param {AgentResource} agentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public create(agentResource: AgentResource, options?: any) {
        return AgentApiFp(this.configuration).create(agentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new CircleCI agent. Returns the created agent detail.
     * @param {CircleCIAgentResource} circleCIAgentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public create4(circleCIAgentResource: CircleCIAgentResource, options?: any) {
        return AgentApiFp(this.configuration).create4(circleCIAgentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a K8S agent. Returns the created agent detail.
     * @param {K8SAgentResource} k8SAgentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public create5(k8SAgentResource: K8SAgentResource, options?: any) {
        return AgentApiFp(this.configuration).create5(k8SAgentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generates the configuration file for the Local agent. Returns the configuration file.
     * @param {AgentConfigResource} agentConfigResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public generateAgent(agentConfigResource: AgentConfigResource, options?: any) {
        return AgentApiFp(this.configuration).generateAgent(agentConfigResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Local agent. Returns the agent detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public get(id: number, options?: any) {
        return AgentApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a CircleCI agent detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public get11(id: number, options?: any) {
        return AgentApiFp(this.configuration).get11(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a K8S agent detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public get13(id: number, options?: any) {
        return AgentApiFp(this.configuration).get13(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircleCIConnectionResource} circleCIConnectionResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public getFollowedProjects(circleCIConnectionResource: CircleCIConnectionResource, options?: any) {
        return AgentApiFp(this.configuration).getFollowedProjects(circleCIConnectionResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
     * @param {CircleCIAgentResource} circleCIAgentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public update6(circleCIAgentResource: CircleCIAgentResource, options?: any) {
        return AgentApiFp(this.configuration).update6(circleCIAgentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a K8S agent detail. Returns the updated agent detail.
     * @param {K8SAgentResource} k8SAgentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public update7(k8SAgentResource: K8SAgentResource, options?: any) {
        return AgentApiFp(this.configuration).update7(k8SAgentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the threshold for Local agent. Returns the agent detail.
     * @param {AgentResource} agentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public updateThreshold(agentResource: AgentResource, options?: any) {
        return AgentApiFp(this.configuration).updateThreshold(agentResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentApi - axios parameter creator
 * @export
 */
export const CommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (commentResource: CommentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentResource' is not null or undefined
            if (commentResource === null || commentResource === undefined) {
                throw new RequiredError('commentResource','Required parameter commentResource was null or undefined when calling create1.');
            }
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof commentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(commentResource !== undefined ? commentResource : {})
                : (commentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (commentResource: CommentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentResource' is not null or undefined
            if (commentResource === null || commentResource === undefined) {
                throw new RequiredError('commentResource','Required parameter commentResource was null or undefined when calling update.');
            }
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof commentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(commentResource !== undefined ? commentResource : {})
                : (commentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentApi - functional programming interface
 * @export
 */
export const CommentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(commentResource: CommentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResource>> {
            const localVarAxiosArgs = await CommentApiAxiosParamCreator(configuration).create1(commentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(commentResource: CommentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResource>> {
            const localVarAxiosArgs = await CommentApiAxiosParamCreator(configuration).update(commentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CommentApi - factory interface
 * @export
 */
export const CommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(commentResource: CommentResource, options?: any): AxiosPromise<CommentResource> {
            return CommentApiFp(configuration).create1(commentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(commentResource: CommentResource, options?: any): AxiosPromise<CommentResource> {
            return CommentApiFp(configuration).update(commentResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
export class CommentApi extends BaseAPI {
    /**
     * 
     * @summary Creates a Comment. Returns the created Comment detail.
     * @param {CommentResource} commentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public create1(commentResource: CommentResource, options?: any) {
        return CommentApiFp(this.configuration).create1(commentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Comment detail. Returns the updated Comment detail.
     * @param {CommentResource} commentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public update(commentResource: CommentResource, options?: any) {
        return CommentApiFp(this.configuration).update(commentResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExecutionApi - axios parameter creator
 * @export
 */
export const ExecutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id 
         * @param {number} projectId 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload: async (id: Array<number>, projectId: number, fileType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bulkDownload.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling bulkDownload.');
            }
            const localVarPath = `/api/v1/executions/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId 
         * @param {Array<number>} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (projectId: number, order: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling delete1.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling delete1.');
            }
            const localVarPath = `/api/v1/executions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (order) {
                localVarQueryParameter['order'] = order;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1: async (id: number, fileType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling download1.');
            }
            const localVarPath = `/api/v1/executions/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/api/v1/executions/{id}/download-file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get1.');
            }
            const localVarPath = `/api/v1/executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExecutions: async (id: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLatestExecutions.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getLatestExecutions.');
            }
            const localVarPath = `/api/v1/organizations/{id}/latest-executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease: async (id: number, projectId: number, releaseId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkRelease.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling linkRelease.');
            }
            // verify required parameter 'releaseId' is not null or undefined
            if (releaseId === null || releaseId === undefined) {
                throw new RequiredError('releaseId','Required parameter releaseId was null or undefined when calling linkRelease.');
            }
            const localVarPath = `/api/v1/executions/{id}/link-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (releaseId !== undefined) {
                localVarQueryParameter['releaseId'] = releaseId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [batch] 
         * @param {number} [projectId] 
         * @param {number} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (pageable: Pageable, batch?: string, projectId?: number, order?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling list.');
            }
            const localVarPath = `/api/v1/executions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reImportExecution: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling reImportExecution.');
            }
            const localVarPath = `/api/v1/executions/reimport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rerun an Execution.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunExecution: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rerunExecution.');
            }
            const localVarPath = `/api/v1/executions/{id}/rerun`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id 
         * @param {ExecutionShareReportResource} executionShareReportResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareExecutionReport: async (id: number, executionShareReportResource: ExecutionShareReportResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling shareExecutionReport.');
            }
            // verify required parameter 'executionShareReportResource' is not null or undefined
            if (executionShareReportResource === null || executionShareReportResource === undefined) {
                throw new RequiredError('executionShareReportResource','Required parameter executionShareReportResource was null or undefined when calling shareExecutionReport.');
            }
            const localVarPath = `/api/v1/executions/{id}/share-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof executionShareReportResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(executionShareReportResource !== undefined ? executionShareReportResource : {})
                : (executionShareReportResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId 
         * @param {number} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatedExecution: async (projectId: number, order: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling terminatedExecution.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling terminatedExecution.');
            }
            const localVarPath = `/api/v1/executions/terminate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkRelease.');
            }
            const localVarPath = `/api/v1/executions/{id}/unlink-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionApi - functional programming interface
 * @export
 */
export const ExecutionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id 
         * @param {number} projectId 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDownload(id: Array<number>, projectId: number, fileType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).bulkDownload(id, projectId, fileType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId 
         * @param {Array<number>} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(projectId: number, order: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExecutionResource>>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).delete1(projectId, order, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download1(id: number, fileType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).download1(id, fileType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).downloadFile(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns an Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).get1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestExecutions(id: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).getLatestExecutions(id, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkRelease(id: number, projectId: number, releaseId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).linkRelease(id, projectId, releaseId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [batch] 
         * @param {number} [projectId] 
         * @param {number} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(pageable: Pageable, batch?: string, projectId?: number, order?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).list(pageable, batch, projectId, order, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reImportExecution(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).reImportExecution(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Rerun an Execution.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rerunExecution(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).rerunExecution(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id 
         * @param {ExecutionShareReportResource} executionShareReportResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareExecutionReport(id: number, executionShareReportResource: ExecutionShareReportResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).shareExecutionReport(id, executionShareReportResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId 
         * @param {number} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminatedExecution(projectId: number, order: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).terminatedExecution(projectId, order, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkRelease(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await ExecutionApiAxiosParamCreator(configuration).unlinkRelease(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExecutionApi - factory interface
 * @export
 */
export const ExecutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id 
         * @param {number} projectId 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload(id: Array<number>, projectId: number, fileType?: string, options?: any): AxiosPromise<void> {
            return ExecutionApiFp(configuration).bulkDownload(id, projectId, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId 
         * @param {Array<number>} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(projectId: number, order: Array<number>, options?: any): AxiosPromise<Array<ExecutionResource>> {
            return ExecutionApiFp(configuration).delete1(projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1(id: number, fileType?: string, options?: any): AxiosPromise<void> {
            return ExecutionApiFp(configuration).download1(id, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: number, options?: any): AxiosPromise<void> {
            return ExecutionApiFp(configuration).downloadFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(id: number, options?: any): AxiosPromise<ExecutionResource> {
            return ExecutionApiFp(configuration).get1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExecutions(id: number, pageable: Pageable, options?: any): AxiosPromise<PageExecutionResource> {
            return ExecutionApiFp(configuration).getLatestExecutions(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease(id: number, projectId: number, releaseId: number, options?: any): AxiosPromise<ExecutionResource> {
            return ExecutionApiFp(configuration).linkRelease(id, projectId, releaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Pageable} pageable 
         * @param {string} [batch] 
         * @param {number} [projectId] 
         * @param {number} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pageable: Pageable, batch?: string, projectId?: number, order?: number, options?: any): AxiosPromise<object> {
            return ExecutionApiFp(configuration).list(pageable, batch, projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reImportExecution(id: number, options?: any): AxiosPromise<ExecutionResource> {
            return ExecutionApiFp(configuration).reImportExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rerun an Execution.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunExecution(id: number, options?: any): AxiosPromise<void> {
            return ExecutionApiFp(configuration).rerunExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id 
         * @param {ExecutionShareReportResource} executionShareReportResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareExecutionReport(id: number, executionShareReportResource: ExecutionShareReportResource, options?: any): AxiosPromise<void> {
            return ExecutionApiFp(configuration).shareExecutionReport(id, executionShareReportResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId 
         * @param {number} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatedExecution(projectId: number, order: number, options?: any): AxiosPromise<ExecutionResource> {
            return ExecutionApiFp(configuration).terminatedExecution(projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease(id: number, options?: any): AxiosPromise<ExecutionResource> {
            return ExecutionApiFp(configuration).unlinkRelease(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExecutionApi - object-oriented interface
 * @export
 * @class ExecutionApi
 * @extends {BaseAPI}
 */
export class ExecutionApi extends BaseAPI {
    /**
     * 
     * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
     * @param {Array<number>} id 
     * @param {number} projectId 
     * @param {string} [fileType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public bulkDownload(id: Array<number>, projectId: number, fileType?: string, options?: any) {
        return ExecutionApiFp(this.configuration).bulkDownload(id, projectId, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes multiple Executions. Returns the deleted Execution details.
     * @param {number} projectId 
     * @param {Array<number>} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public delete1(projectId: number, order: Array<number>, options?: any) {
        return ExecutionApiFp(this.configuration).delete1(projectId, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Exports and downloads an Execution. Returns the Execution summary file.
     * @param {number} id 
     * @param {string} [fileType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public download1(id: number, fileType?: string, options?: any) {
        return ExecutionApiFp(this.configuration).download1(id, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public downloadFile(id: number, options?: any) {
        return ExecutionApiFp(this.configuration).downloadFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an Execution detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public get1(id: number, options?: any) {
        return ExecutionApiFp(this.configuration).get1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public getLatestExecutions(id: number, pageable: Pageable, options?: any) {
        return ExecutionApiFp(this.configuration).getLatestExecutions(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link an Execution to a Release. Returns the updated Execution detail.
     * @param {number} id 
     * @param {number} projectId 
     * @param {number} releaseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public linkRelease(id: number, projectId: number, releaseId: number, options?: any) {
        return ExecutionApiFp(this.configuration).linkRelease(id, projectId, releaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Pageable} pageable 
     * @param {string} [batch] 
     * @param {number} [projectId] 
     * @param {number} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public list(pageable: Pageable, batch?: string, projectId?: number, order?: number, options?: any) {
        return ExecutionApiFp(this.configuration).list(pageable, batch, projectId, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Re-imports an Execution. Returns the newly imported Execution detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public reImportExecution(id: number, options?: any) {
        return ExecutionApiFp(this.configuration).reImportExecution(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rerun an Execution.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public rerunExecution(id: number, options?: any) {
        return ExecutionApiFp(this.configuration).rerunExecution(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allow users to send email with attached execution reports [PDF].
     * @param {number} id 
     * @param {ExecutionShareReportResource} executionShareReportResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public shareExecutionReport(id: number, executionShareReportResource: ExecutionShareReportResource, options?: any) {
        return ExecutionApiFp(this.configuration).shareExecutionReport(id, executionShareReportResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminates a running Execution. Returns the terminated Execution detail.
     * @param {number} projectId 
     * @param {number} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public terminatedExecution(projectId: number, order: number, options?: any) {
        return ExecutionApiFp(this.configuration).terminatedExecution(projectId, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    public unlinkRelease(id: number, options?: any) {
        return ExecutionApiFp(this.configuration).unlinkRelease(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExecutionRequestApi - axios parameter creator
 * @export
 */
export const ExecutionRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (id: number, fileType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling download.');
            }
            const localVarPath = `/api/v1/requests/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an Execution Request detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRequest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExecutionRequest.');
            }
            const localVarPath = `/api/v1/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionRequestApi - functional programming interface
 * @export
 */
export const ExecutionRequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(id: number, fileType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExecutionRequestApiAxiosParamCreator(configuration).download(id, fileType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns an Execution Request detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionRequest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionRequestResource>> {
            const localVarAxiosArgs = await ExecutionRequestApiAxiosParamCreator(configuration).getExecutionRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExecutionRequestApi - factory interface
 * @export
 */
export const ExecutionRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id: number, fileType?: string, options?: any): AxiosPromise<void> {
            return ExecutionRequestApiFp(configuration).download(id, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an Execution Request detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRequest(id: number, options?: any): AxiosPromise<ExecutionRequestResource> {
            return ExecutionRequestApiFp(configuration).getExecutionRequest(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExecutionRequestApi - object-oriented interface
 * @export
 * @class ExecutionRequestApi
 * @extends {BaseAPI}
 */
export class ExecutionRequestApi extends BaseAPI {
    /**
     * 
     * @summary Downloads an Execution Request report. Returns the report file.
     * @param {number} id 
     * @param {string} [fileType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionRequestApi
     */
    public download(id: number, fileType?: string, options?: any) {
        return ExecutionRequestApiFp(this.configuration).download(id, fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an Execution Request detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionRequestApi
     */
    public getExecutionRequest(id: number, options?: any) {
        return ExecutionRequestApiFp(this.configuration).getExecutionRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExecutionTestResultApi - axios parameter creator
 * @export
 */
export const ExecutionTestResultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Result detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get2.');
            }
            const localVarPath = `/api/v1/test-results/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStdout: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStdout.');
            }
            const localVarPath = `/api/v1/test-results/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIncidents: async (id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkIncidents.');
            }
            // verify required parameter 'incidentExecutionTestResultResource' is not null or undefined
            if (incidentExecutionTestResultResource === null || incidentExecutionTestResultResource === undefined) {
                throw new RequiredError('incidentExecutionTestResultResource','Required parameter incidentExecutionTestResultResource was null or undefined when calling linkIncidents.');
            }
            const localVarPath = `/api/v1/test-results/{id}/incidents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof incidentExecutionTestResultResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(incidentExecutionTestResultResource !== undefined ? incidentExecutionTestResultResource : {})
                : (incidentExecutionTestResultResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRetested: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling markAsRetested.');
            }
            const localVarPath = `/api/v1/test-results/{id}/mask-as-retested`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIncidents: async (id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkIncidents.');
            }
            // verify required parameter 'incidentExecutionTestResultResource' is not null or undefined
            if (incidentExecutionTestResultResource === null || incidentExecutionTestResultResource === undefined) {
                throw new RequiredError('incidentExecutionTestResultResource','Required parameter incidentExecutionTestResultResource was null or undefined when calling unlinkIncidents.');
            }
            const localVarPath = `/api/v1/test-results/{id}/incidents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof incidentExecutionTestResultResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(incidentExecutionTestResultResource !== undefined ? incidentExecutionTestResultResource : {})
                : (incidentExecutionTestResultResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionTestResultApi - functional programming interface
 * @export
 */
export const ExecutionTestResultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Result detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionTestResultResource>> {
            const localVarAxiosArgs = await ExecutionTestResultApiAxiosParamCreator(configuration).get2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStdout(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ExecutionTestResultApiAxiosParamCreator(configuration).getStdout(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentExecutionTestResultResource>> {
            const localVarAxiosArgs = await ExecutionTestResultApiAxiosParamCreator(configuration).linkIncidents(id, incidentExecutionTestResultResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsRetested(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionTestResultResource>> {
            const localVarAxiosArgs = await ExecutionTestResultApiAxiosParamCreator(configuration).markAsRetested(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentExecutionTestResultResource>> {
            const localVarAxiosArgs = await ExecutionTestResultApiAxiosParamCreator(configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExecutionTestResultApi - factory interface
 * @export
 */
export const ExecutionTestResultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Result detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(id: string, options?: any): AxiosPromise<ExecutionTestResultResource> {
            return ExecutionTestResultApiFp(configuration).get2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStdout(id: number, options?: any): AxiosPromise<string> {
            return ExecutionTestResultApiFp(configuration).getStdout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any): AxiosPromise<IncidentExecutionTestResultResource> {
            return ExecutionTestResultApiFp(configuration).linkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRetested(id: string, options?: any): AxiosPromise<ExecutionTestResultResource> {
            return ExecutionTestResultApiFp(configuration).markAsRetested(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id 
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any): AxiosPromise<IncidentExecutionTestResultResource> {
            return ExecutionTestResultApiFp(configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExecutionTestResultApi - object-oriented interface
 * @export
 * @class ExecutionTestResultApi
 * @extends {BaseAPI}
 */
export class ExecutionTestResultApi extends BaseAPI {
    /**
     * 
     * @summary Returns an Execution Test Result detail.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    public get2(id: string, options?: any) {
        return ExecutionTestResultApiFp(this.configuration).get2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a test result\'s log. Returns the log file.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    public getStdout(id: number, options?: any) {
        return ExecutionTestResultApiFp(this.configuration).getStdout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
     * @param {string} id 
     * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    public linkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any) {
        return ExecutionTestResultApiFp(this.configuration).linkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    public markAsRetested(id: string, options?: any) {
        return ExecutionTestResultApiFp(this.configuration).markAsRetested(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
     * @param {string} id 
     * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    public unlinkIncidents(id: string, incidentExecutionTestResultResource: IncidentExecutionTestResultResource, options?: any) {
        return ExecutionTestResultApiFp(this.configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExecutionTestSuiteApi - axios parameter creator
 * @export
 */
export const ExecutionTestSuiteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get3.');
            }
            const localVarPath = `/api/v1/execution-test-suites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExecutionTestSuiteApi - functional programming interface
 * @export
 */
export const ExecutionTestSuiteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionTestSuiteResource>> {
            const localVarAxiosArgs = await ExecutionTestSuiteApiAxiosParamCreator(configuration).get3(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExecutionTestSuiteApi - factory interface
 * @export
 */
export const ExecutionTestSuiteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(id: string, options?: any): AxiosPromise<ExecutionTestSuiteResource> {
            return ExecutionTestSuiteApiFp(configuration).get3(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExecutionTestSuiteApi - object-oriented interface
 * @export
 * @class ExecutionTestSuiteApi
 * @extends {BaseAPI}
 */
export class ExecutionTestSuiteApi extends BaseAPI {
    /**
     * 
     * @summary Returns an Execution Test Suite detail.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestSuiteApi
     */
    public get3(id: string, options?: any) {
        return ExecutionTestSuiteApiFp(this.configuration).get3(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download2: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling download2.');
            }
            const localVarPath = `/api/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an upload URL.
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl: async (projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getUploadUrl.');
            }
            const localVarPath = `/api/v1/files/upload-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns multiple upload URLs.
         * @param {number} projectId 
         * @param {number} numberUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrls: async (projectId: number, numberUrl: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getUploadUrls.');
            }
            // verify required parameter 'numberUrl' is not null or undefined
            if (numberUrl === null || numberUrl === undefined) {
                throw new RequiredError('numberUrl','Required parameter numberUrl was null or undefined when calling getUploadUrls.');
            }
            const localVarPath = `/api/v1/files/upload-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (numberUrl !== undefined) {
                localVarQueryParameter['numberUrl'] = numberUrl;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download2(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FileApiAxiosParamCreator(configuration).download2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns an upload URL.
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadUrl(projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResource>> {
            const localVarAxiosArgs = await FileApiAxiosParamCreator(configuration).getUploadUrl(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns multiple upload URLs.
         * @param {number} projectId 
         * @param {number} numberUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadUrls(projectId: number, numberUrl: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileResource>>> {
            const localVarAxiosArgs = await FileApiAxiosParamCreator(configuration).getUploadUrls(projectId, numberUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Downloads a file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download2(id: number, options?: any): AxiosPromise<void> {
            return FileApiFp(configuration).download2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an upload URL.
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(projectId: number, options?: any): AxiosPromise<FileResource> {
            return FileApiFp(configuration).getUploadUrl(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns multiple upload URLs.
         * @param {number} projectId 
         * @param {number} numberUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrls(projectId: number, numberUrl: number, options?: any): AxiosPromise<Array<FileResource>> {
            return FileApiFp(configuration).getUploadUrls(projectId, numberUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @summary Downloads a file.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public download2(id: number, options?: any) {
        return FileApiFp(this.configuration).download2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an upload URL.
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getUploadUrl(projectId: number, options?: any) {
        return FileApiFp(this.configuration).getUploadUrl(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns multiple upload URLs.
     * @param {number} projectId 
     * @param {number} numberUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getUploadUrls(projectId: number, numberUrl: number, options?: any) {
        return FileApiFp(this.configuration).getUploadUrls(projectId, numberUrl, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a Job.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
            }
            const localVarPath = `/api/v1/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Job detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get12: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get12.');
            }
            const localVarPath = `/api/v1/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (uuid: string, teamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getJob.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling getJob.');
            }
            const localVarPath = `/api/v1/jobs/get-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestJobs: async (id: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLatestJobs.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getLatestJobs.');
            }
            const localVarPath = `/api/v1/organizations/{id}/latest-jobs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Job\'s log.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLog.');
            }
            const localVarPath = `/api/v1/jobs/{id}/get-log`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningJobs: async (id: number, pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRunningJobs.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling getRunningJobs.');
            }
            const localVarPath = `/api/v1/organizations/{id}/running-jobs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob: async (jobResource: JobResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobResource' is not null or undefined
            if (jobResource === null || jobResource === undefined) {
                throw new RequiredError('jobResource','Required parameter jobResource was null or undefined when calling updateJob.');
            }
            const localVarPath = `/api/v1/jobs/update-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof jobResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(jobResource !== undefined ? jobResource : {})
                : (jobResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a Job.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).cancel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Job detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get12(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResource>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).get12(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(uuid: string, teamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResource>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getJob(uuid, teamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestJobs(id: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageJobResource>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getLatestJobs(id, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Job\'s log.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildLog>>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getLog(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunningJobs(id: number, pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageJobResource>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).getRunningJobs(id, pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJob(jobResource: JobResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResource>> {
            const localVarAxiosArgs = await JobApiAxiosParamCreator(configuration).updateJob(jobResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Cancels a Job.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<void> {
            return JobApiFp(configuration).cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Job detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get12(id: number, options?: any): AxiosPromise<JobResource> {
            return JobApiFp(configuration).get12(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(uuid: string, teamId: number, options?: any): AxiosPromise<JobResource> {
            return JobApiFp(configuration).getJob(uuid, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestJobs(id: number, pageable: Pageable, options?: any): AxiosPromise<PageJobResource> {
            return JobApiFp(configuration).getLatestJobs(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Job\'s log.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(id: string, options?: any): AxiosPromise<Array<BuildLog>> {
            return JobApiFp(configuration).getLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningJobs(id: number, pageable: Pageable, options?: any): AxiosPromise<PageJobResource> {
            return JobApiFp(configuration).getRunningJobs(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(jobResource: JobResource, options?: any): AxiosPromise<JobResource> {
            return JobApiFp(configuration).updateJob(jobResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a Job.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public cancel(id: string, options?: any) {
        return JobApiFp(this.configuration).cancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Job detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public get12(id: number, options?: any) {
        return JobApiFp(this.configuration).get12(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the next queued Job of an Agent.
     * @param {string} uuid 
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJob(uuid: string, teamId: number, options?: any) {
        return JobApiFp(this.configuration).getJob(uuid, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getLatestJobs(id: number, pageable: Pageable, options?: any) {
        return JobApiFp(this.configuration).getLatestJobs(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Job\'s log.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getLog(id: string, options?: any) {
        return JobApiFp(this.configuration).getLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getRunningJobs(id: number, pageable: Pageable, options?: any) {
        return JobApiFp(this.configuration).getRunningJobs(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Job detail. Returns the updated Job detail.
     * @param {JobResource} jobResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public updateJob(jobResource: JobResource, options?: any) {
        return JobApiFp(this.configuration).updateJob(jobResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KatalonRecorderApi - axios parameter creator
 * @export
 */
export const KatalonRecorderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup: async (uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling backup.');
            }
            const localVarPath = `/api/v1/katalon-recorder/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download3: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling download3.');
            }
            const localVarPath = `/api/v1/katalon-recorder/backup/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (projectId: string, batch: string, isEnd: string, fileName: string, uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling upload.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling upload.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new RequiredError('isEnd','Required parameter isEnd was null or undefined when calling upload.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling upload.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling upload.');
            }
            const localVarPath = `/api/v1/katalon-recorder/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KatalonRecorderApi - functional programming interface
 * @export
 */
export const KatalonRecorderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backup(uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KatalonRecorderApiAxiosParamCreator(configuration).backup(uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download3(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KatalonRecorderApiAxiosParamCreator(configuration).download3(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(projectId: string, batch: string, isEnd: string, fileName: string, uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await KatalonRecorderApiAxiosParamCreator(configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KatalonRecorderApi - factory interface
 * @export
 */
export const KatalonRecorderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(uploadedPath: string, options?: any): AxiosPromise<void> {
            return KatalonRecorderApiFp(configuration).backup(uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download3(id: number, options?: any): AxiosPromise<void> {
            return KatalonRecorderApiFp(configuration).download3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(projectId: string, batch: string, isEnd: string, fileName: string, uploadedPath: string, options?: any): AxiosPromise<void> {
            return KatalonRecorderApiFp(configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KatalonRecorderApi - object-oriented interface
 * @export
 * @class KatalonRecorderApi
 * @extends {BaseAPI}
 */
export class KatalonRecorderApi extends BaseAPI {
    /**
     * 
     * @summary Saves a Katalon Recorder backup detail.
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    public backup(uploadedPath: string, options?: any) {
        return KatalonRecorderApiFp(this.configuration).backup(uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a Katalon Recorder backup. Returns the backup file.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    public download3(id: number, options?: any) {
        return KatalonRecorderApiFp(this.configuration).download3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads and processes a Katalon Recorder report.
     * @param {string} projectId 
     * @param {string} batch 
     * @param {string} isEnd 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    public upload(projectId: string, batch: string, isEnd: string, fileName: string, uploadedPath: string, options?: any) {
        return KatalonRecorderApiFp(this.configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationTrialRequestResourceControllerApi - axios parameter creator
 * @export
 */
export const OrganizationTrialRequestResourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get organization trial request data
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialRequest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTrialRequest.');
            }
            const localVarPath = `/api/v1/organizations/{id}/trial-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit organization trial request
         * @param {number} id 
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTrialRequest: async (id: number, organizationTrialRequestResource: OrganizationTrialRequestResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submitTrialRequest.');
            }
            // verify required parameter 'organizationTrialRequestResource' is not null or undefined
            if (organizationTrialRequestResource === null || organizationTrialRequestResource === undefined) {
                throw new RequiredError('organizationTrialRequestResource','Required parameter organizationTrialRequestResource was null or undefined when calling submitTrialRequest.');
            }
            const localVarPath = `/api/v1/organizations/{id}/trial-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof organizationTrialRequestResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(organizationTrialRequestResource !== undefined ? organizationTrialRequestResource : {})
                : (organizationTrialRequestResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationTrialRequestResourceControllerApi - functional programming interface
 * @export
 */
export const OrganizationTrialRequestResourceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get organization trial request data
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrialRequest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationTrialRequestResource>> {
            const localVarAxiosArgs = await OrganizationTrialRequestResourceControllerApiAxiosParamCreator(configuration).getTrialRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit organization trial request
         * @param {number} id 
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTrialRequest(id: number, organizationTrialRequestResource: OrganizationTrialRequestResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationTrialRequestResource>> {
            const localVarAxiosArgs = await OrganizationTrialRequestResourceControllerApiAxiosParamCreator(configuration).submitTrialRequest(id, organizationTrialRequestResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationTrialRequestResourceControllerApi - factory interface
 * @export
 */
export const OrganizationTrialRequestResourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get organization trial request data
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialRequest(id: number, options?: any): AxiosPromise<OrganizationTrialRequestResource> {
            return OrganizationTrialRequestResourceControllerApiFp(configuration).getTrialRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit organization trial request
         * @param {number} id 
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTrialRequest(id: number, organizationTrialRequestResource: OrganizationTrialRequestResource, options?: any): AxiosPromise<OrganizationTrialRequestResource> {
            return OrganizationTrialRequestResourceControllerApiFp(configuration).submitTrialRequest(id, organizationTrialRequestResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationTrialRequestResourceControllerApi - object-oriented interface
 * @export
 * @class OrganizationTrialRequestResourceControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationTrialRequestResourceControllerApi extends BaseAPI {
    /**
     * 
     * @summary Get organization trial request data
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationTrialRequestResourceControllerApi
     */
    public getTrialRequest(id: number, options?: any) {
        return OrganizationTrialRequestResourceControllerApiFp(this.configuration).getTrialRequest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit organization trial request
     * @param {number} id 
     * @param {OrganizationTrialRequestResource} organizationTrialRequestResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationTrialRequestResourceControllerApi
     */
    public submitTrialRequest(id: number, organizationTrialRequestResource: OrganizationTrialRequestResource, options?: any) {
        return OrganizationTrialRequestResourceControllerApiFp(this.configuration).submitTrialRequest(id, organizationTrialRequestResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (projectResource: ProjectResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new RequiredError('projectResource','Required parameter projectResource was null or undefined when calling create2.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProjectSettingResource} projectSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate: async (projectSettingResource: ProjectSettingResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectSettingResource' is not null or undefined
            if (projectSettingResource === null || projectSettingResource === undefined) {
                throw new RequiredError('projectSettingResource','Required parameter projectSettingResource was null or undefined when calling createOrUpdate.');
            }
            const localVarPath = `/api/v1/project-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectSettingResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectSettingResource !== undefined ? projectSettingResource : {})
                : (projectSettingResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create sample data for project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleData: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createSampleData.');
            }
            const localVarPath = `/api/v1/projects/{id}/sample-data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete2.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get5: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get5.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get6: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get6.');
            }
            const localVarPath = `/api/v1/project-settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable 
         * @param {number} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (pageable: Pageable, teamId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling list1.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (projectResource: ProjectResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new RequiredError('projectResource','Required parameter projectResource was null or undefined when calling update2.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (projectResource: ProjectResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new RequiredError('projectResource','Required parameter projectResource was null or undefined when calling updateStatus.');
            }
            const localVarPath = `/api/v1/projects/update-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(projectResource: ProjectResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).create2(projectResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ProjectSettingResource} projectSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdate(projectSettingResource: ProjectSettingResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSettingResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).createOrUpdate(projectSettingResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create sample data for project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSampleData(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).createSampleData(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).delete2(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get5(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).get5(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get6(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSettingResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).get6(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable 
         * @param {number} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(pageable: Pageable, teamId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).list1(pageable, teamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(projectResource: ProjectResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).update2(projectResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(projectResource: ProjectResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResource>> {
            const localVarAxiosArgs = await ProjectApiAxiosParamCreator(configuration).updateStatus(projectResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(projectResource: ProjectResource, options?: any): AxiosPromise<ProjectResource> {
            return ProjectApiFp(configuration).create2(projectResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProjectSettingResource} projectSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate(projectSettingResource: ProjectSettingResource, options?: any): AxiosPromise<ProjectSettingResource> {
            return ProjectApiFp(configuration).createOrUpdate(projectSettingResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create sample data for project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleData(id: number, options?: any): AxiosPromise<void> {
            return ProjectApiFp(configuration).createSampleData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: number, options?: any): AxiosPromise<ProjectResource> {
            return ProjectApiFp(configuration).delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get5(id: number, options?: any): AxiosPromise<ProjectResource> {
            return ProjectApiFp(configuration).get5(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get6(id: number, options?: any): AxiosPromise<ProjectSettingResource> {
            return ProjectApiFp(configuration).get6(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable 
         * @param {number} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(pageable: Pageable, teamId?: number, options?: any): AxiosPromise<PageProjectResource> {
            return ProjectApiFp(configuration).list1(pageable, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(projectResource: ProjectResource, options?: any): AxiosPromise<ProjectResource> {
            return ProjectApiFp(configuration).update2(projectResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(projectResource: ProjectResource, options?: any): AxiosPromise<ProjectResource> {
            return ProjectApiFp(configuration).updateStatus(projectResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new Project. Returns the created Project detail.
     * @param {ProjectResource} projectResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public create2(projectResource: ProjectResource, options?: any) {
        return ProjectApiFp(this.configuration).create2(projectResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProjectSettingResource} projectSettingResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createOrUpdate(projectSettingResource: ProjectSettingResource, options?: any) {
        return ProjectApiFp(this.configuration).createOrUpdate(projectSettingResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create sample data for project.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createSampleData(id: number, options?: any) {
        return ProjectApiFp(this.configuration).createSampleData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a Project. Returns the deleted Project detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public delete2(id: number, options?: any) {
        return ProjectApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Project detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public get5(id: number, options?: any) {
        return ProjectApiFp(this.configuration).get5(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public get6(id: number, options?: any) {
        return ProjectApiFp(this.configuration).get6(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all Projects of a Team.
     * @param {Pageable} pageable 
     * @param {number} [teamId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public list1(pageable: Pageable, teamId?: number, options?: any) {
        return ProjectApiFp(this.configuration).list1(pageable, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Project detail. Returns the updated Project detail.
     * @param {ProjectResource} projectResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public update2(projectResource: ProjectResource, options?: any) {
        return ProjectApiFp(this.configuration).update2(projectResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Project status. Returns the updated Project detail.
     * @param {ProjectResource} projectResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateStatus(projectResource: ProjectResource, options?: any) {
        return ProjectApiFp(this.configuration).updateStatus(projectResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectConfigurationResourceControllerApi - axios parameter creator
 * @export
 */
export const ProjectConfigurationResourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get14: async (id: number, name: 'TIMEZONE' | 'ASSERTION_PATTERN', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get14.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling get14.');
            }
            const localVarPath = `/api/v1/project-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/time-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ProjectConfigurationResource} projectConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8: async (id: number, projectConfigurationResource: ProjectConfigurationResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling update8.');
            }
            // verify required parameter 'projectConfigurationResource' is not null or undefined
            if (projectConfigurationResource === null || projectConfigurationResource === undefined) {
                throw new RequiredError('projectConfigurationResource','Required parameter projectConfigurationResource was null or undefined when calling update8.');
            }
            const localVarPath = `/api/v1/project-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof projectConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(projectConfigurationResource !== undefined ? projectConfigurationResource : {})
                : (projectConfigurationResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectConfigurationResourceControllerApi - functional programming interface
 * @export
 */
export const ProjectConfigurationResourceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get14(id: number, name: 'TIMEZONE' | 'ASSERTION_PATTERN', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectConfigurationResource>> {
            const localVarAxiosArgs = await ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).get14(id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimeZones(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeZoneResource>>> {
            const localVarAxiosArgs = await ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).listTimeZones(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ProjectConfigurationResource} projectConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update8(id: number, projectConfigurationResource: ProjectConfigurationResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectConfigurationResource>> {
            const localVarAxiosArgs = await ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).update8(id, projectConfigurationResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectConfigurationResourceControllerApi - factory interface
 * @export
 */
export const ProjectConfigurationResourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get14(id: number, name: 'TIMEZONE' | 'ASSERTION_PATTERN', options?: any): AxiosPromise<ProjectConfigurationResource> {
            return ProjectConfigurationResourceControllerApiFp(configuration).get14(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones(options?: any): AxiosPromise<Array<TimeZoneResource>> {
            return ProjectConfigurationResourceControllerApiFp(configuration).listTimeZones(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {ProjectConfigurationResource} projectConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8(id: number, projectConfigurationResource: ProjectConfigurationResource, options?: any): AxiosPromise<ProjectConfigurationResource> {
            return ProjectConfigurationResourceControllerApiFp(configuration).update8(id, projectConfigurationResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectConfigurationResourceControllerApi - object-oriented interface
 * @export
 * @class ProjectConfigurationResourceControllerApi
 * @extends {BaseAPI}
 */
export class ProjectConfigurationResourceControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    public get14(id: number, name: 'TIMEZONE' | 'ASSERTION_PATTERN', options?: any) {
        return ProjectConfigurationResourceControllerApiFp(this.configuration).get14(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    public listTimeZones(options?: any) {
        return ProjectConfigurationResourceControllerApiFp(this.configuration).listTimeZones(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {ProjectConfigurationResource} projectConfigurationResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    public update8(id: number, projectConfigurationResource: ProjectConfigurationResource, options?: any) {
        return ProjectConfigurationResourceControllerApiFp(this.configuration).update8(id, projectConfigurationResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReleaseApi - axios parameter creator
 * @export
 */
export const ReleaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id 
         * @param {boolean} closed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeRelease: async (id: number, closed: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling activeRelease.');
            }
            // verify required parameter 'closed' is not null or undefined
            if (closed === null || closed === undefined) {
                throw new RequiredError('closed','Required parameter closed was null or undefined when calling activeRelease.');
            }
            const localVarPath = `/api/v1/releases/{id}/active`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (closed !== undefined) {
                localVarQueryParameter['closed'] = closed;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate1: async (releaseResource: ReleaseResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'releaseResource' is not null or undefined
            if (releaseResource === null || releaseResource === undefined) {
                throw new RequiredError('releaseResource','Required parameter releaseResource was null or undefined when calling createOrUpdate1.');
            }
            const localVarPath = `/api/v1/releases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof releaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(releaseResource !== undefined ? releaseResource : {})
                : (releaseResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete3.');
            }
            const localVarPath = `/api/v1/releases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (releaseResource: ReleaseResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'releaseResource' is not null or undefined
            if (releaseResource === null || releaseResource === undefined) {
                throw new RequiredError('releaseResource','Required parameter releaseResource was null or undefined when calling update3.');
            }
            const localVarPath = `/api/v1/releases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof releaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(releaseResource !== undefined ? releaseResource : {})
                : (releaseResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleaseApi - functional programming interface
 * @export
 */
export const ReleaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id 
         * @param {boolean} closed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeRelease(id: number, closed: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseResource>> {
            const localVarAxiosArgs = await ReleaseApiAxiosParamCreator(configuration).activeRelease(id, closed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdate1(releaseResource: ReleaseResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseResource>> {
            const localVarAxiosArgs = await ReleaseApiAxiosParamCreator(configuration).createOrUpdate1(releaseResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseResource>> {
            const localVarAxiosArgs = await ReleaseApiAxiosParamCreator(configuration).delete3(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(releaseResource: ReleaseResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseResource>> {
            const localVarAxiosArgs = await ReleaseApiAxiosParamCreator(configuration).update3(releaseResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReleaseApi - factory interface
 * @export
 */
export const ReleaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id 
         * @param {boolean} closed 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeRelease(id: number, closed: boolean, options?: any): AxiosPromise<ReleaseResource> {
            return ReleaseApiFp(configuration).activeRelease(id, closed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate1(releaseResource: ReleaseResource, options?: any): AxiosPromise<ReleaseResource> {
            return ReleaseApiFp(configuration).createOrUpdate1(releaseResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id: number, options?: any): AxiosPromise<ReleaseResource> {
            return ReleaseApiFp(configuration).delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(releaseResource: ReleaseResource, options?: any): AxiosPromise<ReleaseResource> {
            return ReleaseApiFp(configuration).update3(releaseResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleaseApi - object-oriented interface
 * @export
 * @class ReleaseApi
 * @extends {BaseAPI}
 */
export class ReleaseApi extends BaseAPI {
    /**
     * 
     * @summary Open or close a Release. Returns the updated Release detail.
     * @param {number} id 
     * @param {boolean} closed 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public activeRelease(id: number, closed: boolean, options?: any) {
        return ReleaseApiFp(this.configuration).activeRelease(id, closed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates or updates a Release. Returns the Release details.
     * @param {ReleaseResource} releaseResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public createOrUpdate1(releaseResource: ReleaseResource, options?: any) {
        return ReleaseApiFp(this.configuration).createOrUpdate1(releaseResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a Release. Returns the Release details.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public delete3(id: number, options?: any) {
        return ReleaseApiFp(this.configuration).delete3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Release. Returns the Release details.
     * @param {ReleaseResource} releaseResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    public update3(releaseResource: ReleaseResource, options?: any) {
        return ReleaseApiFp(this.configuration).update3(releaseResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling search.');
            }
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1: async (searchRequest: SearchRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchRequest' is not null or undefined
            if (searchRequest === null || searchRequest === undefined) {
                throw new RequiredError('searchRequest','Required parameter searchRequest was null or undefined when calling search1.');
            }
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof searchRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : (searchRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageBaseResource>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).search(q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search1(searchRequest: SearchRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageBaseResource>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).search1(searchRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: SearchConfigResource; }>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).test(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: any): AxiosPromise<PageBaseResource> {
            return SearchApiFp(configuration).search(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchRequest: SearchRequest, options?: any): AxiosPromise<PageBaseResource> {
            return SearchApiFp(configuration).search1(searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: any): AxiosPromise<{ [key: string]: SearchConfigResource; }> {
            return SearchApiFp(configuration).test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
     * @param {string} q 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(q: string, options?: any) {
        return SearchApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
     * @param {SearchRequest} searchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search1(searchRequest: SearchRequest, options?: any) {
        return SearchApiFp(this.configuration).search1(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the search configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public test(options?: any) {
        return SearchApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident: async (incidentResource: IncidentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'incidentResource' is not null or undefined
            if (incidentResource === null || incidentResource === undefined) {
                throw new RequiredError('incidentResource','Required parameter incidentResource was null or undefined when calling createIncident.');
            }
            const localVarPath = `/api/v1/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof incidentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(incidentResource !== undefined ? incidentResource : {})
                : (incidentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Task detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get4.');
            }
            const localVarPath = `/api/v1/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (incidentResource: IncidentResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'incidentResource' is not null or undefined
            if (incidentResource === null || incidentResource === undefined) {
                throw new RequiredError('incidentResource','Required parameter incidentResource was null or undefined when calling update1.');
            }
            const localVarPath = `/api/v1/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof incidentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(incidentResource !== undefined ? incidentResource : {})
                : (incidentResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIncident(incidentResource: IncidentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentResource>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).createIncident(incidentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Task detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get4(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentResource>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).get4(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(incidentResource: IncidentResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentResource>> {
            const localVarAxiosArgs = await TaskApiAxiosParamCreator(configuration).update1(incidentResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident(incidentResource: IncidentResource, options?: any): AxiosPromise<IncidentResource> {
            return TaskApiFp(configuration).createIncident(incidentResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Task detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(id: number, options?: any): AxiosPromise<IncidentResource> {
            return TaskApiFp(configuration).get4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(incidentResource: IncidentResource, options?: any): AxiosPromise<IncidentResource> {
            return TaskApiFp(configuration).update1(incidentResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @summary Creates a Task for the test results. Returns the created Task detail.
     * @param {IncidentResource} incidentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createIncident(incidentResource: IncidentResource, options?: any) {
        return TaskApiFp(this.configuration).createIncident(incidentResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Task detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public get4(id: number, options?: any) {
        return TaskApiFp(this.configuration).get4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Task detail. Returns the updated Task detail.
     * @param {IncidentResource} incidentResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public update1(incidentResource: IncidentResource, options?: any) {
        return TaskApiFp(this.configuration).update1(incidentResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (teamResource: TeamResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamResource' is not null or undefined
            if (teamResource === null || teamResource === undefined) {
                throw new RequiredError('teamResource','Required parameter teamResource was null or undefined when calling create3.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof teamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(teamResource !== undefined ? teamResource : {})
                : (teamResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete4.');
            }
            const localVarPath = `/api/v1/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get7: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get7.');
            }
            const localVarPath = `/api/v1/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable','Required parameter pageable was null or undefined when calling list2.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: async (teamResource: TeamResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamResource' is not null or undefined
            if (teamResource === null || teamResource === undefined) {
                throw new RequiredError('teamResource','Required parameter teamResource was null or undefined when calling update4.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof teamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(teamResource !== undefined ? teamResource : {})
                : (teamResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTeam: async (userTeamResource: UserTeamResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userTeamResource' is not null or undefined
            if (userTeamResource === null || userTeamResource === undefined) {
                throw new RequiredError('userTeamResource','Required parameter userTeamResource was null or undefined when calling updateUserTeam.');
            }
            const localVarPath = `/api/v1/permission/team/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userTeamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userTeamResource !== undefined ? userTeamResource : {})
                : (userTeamResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(teamResource: TeamResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).create3(teamResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).delete4(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get7(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).get7(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list2(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageTeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).list2(pageable, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update4(teamResource: TeamResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).update4(teamResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserTeam(userTeamResource: UserTeamResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTeamResource>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).updateUserTeam(userTeamResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(teamResource: TeamResource, options?: any): AxiosPromise<TeamResource> {
            return TeamApiFp(configuration).create3(teamResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id: number, options?: any): AxiosPromise<TeamResource> {
            return TeamApiFp(configuration).delete4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Team detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get7(id: number, options?: any): AxiosPromise<TeamResource> {
            return TeamApiFp(configuration).get7(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2(pageable: Pageable, options?: any): AxiosPromise<PageTeamResource> {
            return TeamApiFp(configuration).list2(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(teamResource: TeamResource, options?: any): AxiosPromise<TeamResource> {
            return TeamApiFp(configuration).update4(teamResource, options).then((request) => request(axios, basePath));
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTeam(userTeamResource: UserTeamResource, options?: any): AxiosPromise<UserTeamResource> {
            return TeamApiFp(configuration).updateUserTeam(userTeamResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new Team. Returns the created Team detail.
     * @param {TeamResource} teamResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public create3(teamResource: TeamResource, options?: any) {
        return TeamApiFp(this.configuration).create3(teamResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Team. Returns the delete Team detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public delete4(id: number, options?: any) {
        return TeamApiFp(this.configuration).delete4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Team detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public get7(id: number, options?: any) {
        return TeamApiFp(this.configuration).get7(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all Teams of the current User.
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public list2(pageable: Pageable, options?: any) {
        return TeamApiFp(this.configuration).list2(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Team detail. Returns the updated Team detail.
     * @param {TeamResource} teamResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public update4(teamResource: TeamResource, options?: any) {
        return TeamApiFp(this.configuration).update4(teamResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Updates the role of a User in a Team. Returns the updated detail.
     * @param {UserTeamResource} userTeamResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public updateUserTeam(userTeamResource: UserTeamResource, options?: any) {
        return TeamApiFp(this.configuration).updateUserTeam(userTeamResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestCaseApi - axios parameter creator
 * @export
 */
export const TestCaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Case detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get8: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get8.');
            }
            const localVarPath = `/api/v1/test-cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5: async (testCaseResource: TestCaseResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testCaseResource' is not null or undefined
            if (testCaseResource === null || testCaseResource === undefined) {
                throw new RequiredError('testCaseResource','Required parameter testCaseResource was null or undefined when calling update5.');
            }
            const localVarPath = `/api/v1/test-cases/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof testCaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(testCaseResource !== undefined ? testCaseResource : {})
                : (testCaseResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestCaseApi - functional programming interface
 * @export
 */
export const TestCaseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Case detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get8(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseResource>> {
            const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).get8(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update5(testCaseResource: TestCaseResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseResource>> {
            const localVarAxiosArgs = await TestCaseApiAxiosParamCreator(configuration).update5(testCaseResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestCaseApi - factory interface
 * @export
 */
export const TestCaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns a Test Case detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get8(id: string, options?: any): AxiosPromise<TestCaseResource> {
            return TestCaseApiFp(configuration).get8(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(testCaseResource: TestCaseResource, options?: any): AxiosPromise<TestCaseResource> {
            return TestCaseApiFp(configuration).update5(testCaseResource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestCaseApi - object-oriented interface
 * @export
 * @class TestCaseApi
 * @extends {BaseAPI}
 */
export class TestCaseApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Test Case detail.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestCaseApi
     */
    public get8(id: string, options?: any) {
        return TestCaseApiFp(this.configuration).get8(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Test Case.
     * @param {TestCaseResource} testCaseResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestCaseApi
     */
    public update5(testCaseResource: TestCaseResource, options?: any) {
        return TestCaseApiFp(this.configuration).update5(testCaseResource, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestObjectApi - axios parameter creator
 * @export
 */
export const TestObjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Object detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get15: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get15.');
            }
            const localVarPath = `/api/v1/test-object-entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestObjectApi - functional programming interface
 * @export
 */
export const TestObjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Object detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get15(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestObjectEntityResource>> {
            const localVarAxiosArgs = await TestObjectApiAxiosParamCreator(configuration).get15(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestObjectApi - factory interface
 * @export
 */
export const TestObjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns a Test Object detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get15(id: number, options?: any): AxiosPromise<TestObjectEntityResource> {
            return TestObjectApiFp(configuration).get15(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestObjectApi - object-oriented interface
 * @export
 * @class TestObjectApi
 * @extends {BaseAPI}
 */
export class TestObjectApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Test Object detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestObjectApi
     */
    public get15(id: number, options?: any) {
        return TestObjectApiFp(this.configuration).get15(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestPlanApi - axios parameter creator
 * @export
 */
export const TestPlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndTriggerSample: async (runConfigurationResource: RunConfigurationResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'runConfigurationResource' is not null or undefined
            if (runConfigurationResource === null || runConfigurationResource === undefined) {
                throw new RequiredError('runConfigurationResource','Required parameter runConfigurationResource was null or undefined when calling createAndTriggerSample.');
            }
            const localVarPath = `/api/v1/run-configurations/sample`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof runConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(runConfigurationResource !== undefined ? runConfigurationResource : {})
                : (runConfigurationResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {boolean} [verifyRunConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateConfiguration: async (runConfigurationResource: RunConfigurationResource, verifyRunConfiguration?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'runConfigurationResource' is not null or undefined
            if (runConfigurationResource === null || runConfigurationResource === undefined) {
                throw new RequiredError('runConfigurationResource','Required parameter runConfigurationResource was null or undefined when calling createOrUpdateConfiguration.');
            }
            const localVarPath = `/api/v1/run-configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (verifyRunConfiguration !== undefined) {
                localVarQueryParameter['verifyRunConfiguration'] = verifyRunConfiguration;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof runConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(runConfigurationResource !== undefined ? runConfigurationResource : {})
                : (runConfigurationResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete5.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease1: async (id: number, projectId: number, releaseId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkRelease1.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling linkRelease1.');
            }
            // verify required parameter 'releaseId' is not null or undefined
            if (releaseId === null || releaseId === undefined) {
                throw new RequiredError('releaseId','Required parameter releaseId was null or undefined when calling linkRelease1.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/link-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (releaseId !== undefined) {
                localVarQueryParameter['releaseId'] = releaseId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease1: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkRelease1.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/unlink-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestPlanApi - functional programming interface
 * @export
 */
export const TestPlanApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndTriggerSample(runConfigurationResource: RunConfigurationResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunConfigurationResource>> {
            const localVarAxiosArgs = await TestPlanApiAxiosParamCreator(configuration).createAndTriggerSample(runConfigurationResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {boolean} [verifyRunConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateConfiguration(runConfigurationResource: RunConfigurationResource, verifyRunConfiguration?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunConfigurationResource>> {
            const localVarAxiosArgs = await TestPlanApiAxiosParamCreator(configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete5(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunConfigurationResource>> {
            const localVarAxiosArgs = await TestPlanApiAxiosParamCreator(configuration).delete5(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkRelease1(id: number, projectId: number, releaseId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunConfigurationResource>> {
            const localVarAxiosArgs = await TestPlanApiAxiosParamCreator(configuration).linkRelease1(id, projectId, releaseId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkRelease1(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunConfigurationResource>> {
            const localVarAxiosArgs = await TestPlanApiAxiosParamCreator(configuration).unlinkRelease1(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestPlanApi - factory interface
 * @export
 */
export const TestPlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndTriggerSample(runConfigurationResource: RunConfigurationResource, options?: any): AxiosPromise<RunConfigurationResource> {
            return TestPlanApiFp(configuration).createAndTriggerSample(runConfigurationResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource 
         * @param {boolean} [verifyRunConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateConfiguration(runConfigurationResource: RunConfigurationResource, verifyRunConfiguration?: boolean, options?: any): AxiosPromise<RunConfigurationResource> {
            return TestPlanApiFp(configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(id: number, options?: any): AxiosPromise<RunConfigurationResource> {
            return TestPlanApiFp(configuration).delete5(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {number} projectId 
         * @param {number} releaseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease1(id: number, projectId: number, releaseId: number, options?: any): AxiosPromise<RunConfigurationResource> {
            return TestPlanApiFp(configuration).linkRelease1(id, projectId, releaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease1(id: number, options?: any): AxiosPromise<RunConfigurationResource> {
            return TestPlanApiFp(configuration).unlinkRelease1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestPlanApi - object-oriented interface
 * @export
 * @class TestPlanApi
 * @extends {BaseAPI}
 */
export class TestPlanApi extends BaseAPI {
    /**
     * 
     * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
     * @param {RunConfigurationResource} runConfigurationResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    public createAndTriggerSample(runConfigurationResource: RunConfigurationResource, options?: any) {
        return TestPlanApiFp(this.configuration).createAndTriggerSample(runConfigurationResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
     * @param {RunConfigurationResource} runConfigurationResource 
     * @param {boolean} [verifyRunConfiguration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    public createOrUpdateConfiguration(runConfigurationResource: RunConfigurationResource, verifyRunConfiguration?: boolean, options?: any) {
        return TestPlanApiFp(this.configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    public delete5(id: number, options?: any) {
        return TestPlanApiFp(this.configuration).delete5(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
     * @param {number} id 
     * @param {number} projectId 
     * @param {number} releaseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    public linkRelease1(id: number, projectId: number, releaseId: number, options?: any) {
        return TestPlanApiFp(this.configuration).linkRelease1(id, projectId, releaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    public unlinkRelease1(id: number, options?: any) {
        return TestPlanApiFp(this.configuration).unlinkRelease1(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestProjectApi - axios parameter creator
 * @export
 */
export const TestProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6: async (id: number, schedulerResource: SchedulerResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling create6.');
            }
            // verify required parameter 'schedulerResource' is not null or undefined
            if (schedulerResource === null || schedulerResource === undefined) {
                throw new RequiredError('schedulerResource','Required parameter schedulerResource was null or undefined when calling create6.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof schedulerResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(schedulerResource !== undefined ? schedulerResource : {})
                : (schedulerResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitRepo: async (gitRepositoryResource: GitRepositoryResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gitRepositoryResource' is not null or undefined
            if (gitRepositoryResource === null || gitRepositoryResource === undefined) {
                throw new RequiredError('gitRepositoryResource','Required parameter gitRepositoryResource was null or undefined when calling createGitRepo.');
            }
            const localVarPath = `/api/v1/git/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof gitRepositoryResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(gitRepositoryResource !== undefined ? gitRepositoryResource : {})
                : (gitRepositoryResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {'KS' | 'GIT'} type 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSample: async (name: string, type: 'KS' | 'GIT', projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createSample.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createSample.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling createSample.');
            }
            const localVarPath = `/api/v1/test-projects/sample`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete6.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7: async (id: number, schedulerId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete7.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new RequiredError('schedulerId','Required parameter schedulerId was null or undefined when calling delete7.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download4: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling download4.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Test Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get17: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get17.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduler: async (id: number, schedulerId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getScheduler.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new RequiredError('schedulerId','Required parameter schedulerId was null or undefined when calling getScheduler.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestProjectGit: async (testProjectGitId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testProjectGitId' is not null or undefined
            if (testProjectGitId === null || testProjectGitId === undefined) {
                throw new RequiredError('testProjectGitId','Required parameter testProjectGitId was null or undefined when calling getTestProjectGit.');
            }
            const localVarPath = `/api/v1/git/{testProjectGitId}`
                .replace(`{${"testProjectGitId"}}`, encodeURIComponent(String(testProjectGitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTSC: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling refreshTSC.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/refresh-tsc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        run: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling run.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {TestProjectResource} testProjectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10: async (id: number, testProjectResource: TestProjectResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling update10.');
            }
            // verify required parameter 'testProjectResource' is not null or undefined
            if (testProjectResource === null || testProjectResource === undefined) {
                throw new RequiredError('testProjectResource','Required parameter testProjectResource was null or undefined when calling update10.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof testProjectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(testProjectResource !== undefined ? testProjectResource : {})
                : (testProjectResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9: async (id: number, schedulerId: number, schedulerResource: SchedulerResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling update9.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new RequiredError('schedulerId','Required parameter schedulerId was null or undefined when calling update9.');
            }
            // verify required parameter 'schedulerResource' is not null or undefined
            if (schedulerResource === null || schedulerResource === undefined) {
                throw new RequiredError('schedulerResource','Required parameter schedulerResource was null or undefined when calling update9.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof schedulerResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(schedulerResource !== undefined ? schedulerResource : {})
                : (schedulerResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitRepo: async (gitRepositoryResource: GitRepositoryResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gitRepositoryResource' is not null or undefined
            if (gitRepositoryResource === null || gitRepositoryResource === undefined) {
                throw new RequiredError('gitRepositoryResource','Required parameter gitRepositoryResource was null or undefined when calling updateGitRepo.');
            }
            const localVarPath = `/api/v1/git/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof gitRepositoryResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(gitRepositoryResource !== undefined ? gitRepositoryResource : {})
                : (gitRepositoryResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage: async (id: number, batch: string, folderPath: string, fileName: string, uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new RequiredError('folderPath','Required parameter folderPath was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling updatePackage.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/update-package`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1: async (name: string, projectId: string, batch: string, folderPath: string, fileName: string, uploadedPath: string, description?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling upload1.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling upload1.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling upload1.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new RequiredError('folderPath','Required parameter folderPath was null or undefined when calling upload1.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling upload1.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling upload1.');
            }
            const localVarPath = `/api/v1/test-projects/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestProjectApi - functional programming interface
 * @export
 */
export const TestProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create6(id: number, schedulerResource: SchedulerResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchedulerResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).create6(id, schedulerResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).createGitRepo(gitRepositoryResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {'KS' | 'GIT'} type 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSample(name: string, type: 'KS' | 'GIT', projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).createSample(name, type, projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete6(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).delete6(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete7(id: number, schedulerId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchedulerResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).delete7(id, schedulerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download4(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).download4(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Test Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get17(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).get17(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduler(id: number, schedulerId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchedulerResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).getScheduler(id, schedulerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTestProjectGit(testProjectGitId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).getTestProjectGit(testProjectGitId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTSC(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).refreshTSC(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async run(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildInfo>>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).run(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {TestProjectResource} testProjectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update10(id: number, testProjectResource: TestProjectResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).update10(id, testProjectResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update9(id: number, schedulerId: number, schedulerResource: SchedulerResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchedulerResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).update9(id, schedulerId, schedulerResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitRepositoryResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).updateGitRepo(gitRepositoryResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePackage(id: number, batch: string, folderPath: string, fileName: string, uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload1(name: string, projectId: string, batch: string, folderPath: string, fileName: string, uploadedPath: string, description?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestProjectResource>> {
            const localVarAxiosArgs = await TestProjectApiAxiosParamCreator(configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestProjectApi - factory interface
 * @export
 */
export const TestProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6(id: number, schedulerResource: SchedulerResource, options?: any): AxiosPromise<SchedulerResource> {
            return TestProjectApiFp(configuration).create6(id, schedulerResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any): AxiosPromise<GitRepositoryResource> {
            return TestProjectApiFp(configuration).createGitRepo(gitRepositoryResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {'KS' | 'GIT'} type 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSample(name: string, type: 'KS' | 'GIT', projectId: number, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).createSample(name, type, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(id: number, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).delete6(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(id: number, schedulerId: number, options?: any): AxiosPromise<SchedulerResource> {
            return TestProjectApiFp(configuration).delete7(id, schedulerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download4(id: number, options?: any): AxiosPromise<void> {
            return TestProjectApiFp(configuration).download4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Test Project detail.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get17(id: number, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).get17(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduler(id: number, schedulerId: number, options?: any): AxiosPromise<SchedulerResource> {
            return TestProjectApiFp(configuration).getScheduler(id, schedulerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestProjectGit(testProjectGitId: number, options?: any): AxiosPromise<GitRepositoryResource> {
            return TestProjectApiFp(configuration).getTestProjectGit(testProjectGitId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTSC(id: number, options?: any): AxiosPromise<void> {
            return TestProjectApiFp(configuration).refreshTSC(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        run(id: number, options?: any): AxiosPromise<Array<BuildInfo>> {
            return TestProjectApiFp(configuration).run(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {TestProjectResource} testProjectResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10(id: number, testProjectResource: TestProjectResource, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).update10(id, testProjectResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id 
         * @param {number} schedulerId 
         * @param {SchedulerResource} schedulerResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9(id: number, schedulerId: number, schedulerResource: SchedulerResource, options?: any): AxiosPromise<SchedulerResource> {
            return TestProjectApiFp(configuration).update9(id, schedulerId, schedulerResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any): AxiosPromise<GitRepositoryResource> {
            return TestProjectApiFp(configuration).updateGitRepo(gitRepositoryResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage(id: number, batch: string, folderPath: string, fileName: string, uploadedPath: string, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name 
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1(name: string, projectId: string, batch: string, folderPath: string, fileName: string, uploadedPath: string, description?: string, options?: any): AxiosPromise<TestProjectResource> {
            return TestProjectApiFp(configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestProjectApi - object-oriented interface
 * @export
 * @class TestProjectApi
 * @extends {BaseAPI}
 */
export class TestProjectApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
     * @param {number} id 
     * @param {SchedulerResource} schedulerResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public create6(id: number, schedulerResource: SchedulerResource, options?: any) {
        return TestProjectApiFp(this.configuration).create6(id, schedulerResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a Git Test Project. Returns the Git Test Project detail.
     * @param {GitRepositoryResource} gitRepositoryResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public createGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any) {
        return TestProjectApiFp(this.configuration).createGitRepo(gitRepositoryResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new sample Test Project. Returns the created Test Project.
     * @param {string} name 
     * @param {'KS' | 'GIT'} type 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public createSample(name: string, type: 'KS' | 'GIT', projectId: number, options?: any) {
        return TestProjectApiFp(this.configuration).createSample(name, type, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a Test Project. Returns the deleted Test Project.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public delete6(id: number, options?: any) {
        return TestProjectApiFp(this.configuration).delete6(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a schedule. Returns the deleted schedule detail.
     * @param {number} id 
     * @param {number} schedulerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public delete7(id: number, schedulerId: number, options?: any) {
        return TestProjectApiFp(this.configuration).delete7(id, schedulerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a Test Project package. Returns the latest Test Project package file.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public download4(id: number, options?: any) {
        return TestProjectApiFp(this.configuration).download4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Test Project detail.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public get17(id: number, options?: any) {
        return TestProjectApiFp(this.configuration).get17(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a schedule detail.
     * @param {number} id 
     * @param {number} schedulerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public getScheduler(id: number, schedulerId: number, options?: any) {
        return TestProjectApiFp(this.configuration).getScheduler(id, schedulerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a Git Test Project detail.
     * @param {number} testProjectGitId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public getTestProjectGit(testProjectGitId: number, options?: any) {
        return TestProjectApiFp(this.configuration).getTestProjectGit(testProjectGitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Test Suite Collection list of Git Test Project
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public refreshTSC(id: number, options?: any) {
        return TestProjectApiFp(this.configuration).refreshTSC(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Executes a Test Plan. Returns the build information.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public run(id: number, options?: any) {
        return TestProjectApiFp(this.configuration).run(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Test Project detail. Returns the updated Test Project detail.
     * @param {number} id 
     * @param {TestProjectResource} testProjectResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public update10(id: number, testProjectResource: TestProjectResource, options?: any) {
        return TestProjectApiFp(this.configuration).update10(id, testProjectResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a schedule detail. Returns the updated schedule detail.
     * @param {number} id 
     * @param {number} schedulerId 
     * @param {SchedulerResource} schedulerResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public update9(id: number, schedulerId: number, schedulerResource: SchedulerResource, options?: any) {
        return TestProjectApiFp(this.configuration).update9(id, schedulerId, schedulerResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
     * @param {GitRepositoryResource} gitRepositoryResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public updateGitRepo(gitRepositoryResource: GitRepositoryResource, options?: any) {
        return TestProjectApiFp(this.configuration).updateGitRepo(gitRepositoryResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Test Project package. Returns the updated Test Project detail.
     * @param {number} id 
     * @param {string} batch 
     * @param {string} folderPath 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public updatePackage(id: number, batch: string, folderPath: string, fileName: string, uploadedPath: string, options?: any) {
        return TestProjectApiFp(this.configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new Test Project. Returns the created Test Project.
     * @param {string} name 
     * @param {string} projectId 
     * @param {string} batch 
     * @param {string} folderPath 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    public upload1(name: string, projectId: string, batch: string, folderPath: string, fileName: string, uploadedPath: string, description?: string, options?: any) {
        return TestProjectApiFp(this.configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestReportApi - axios parameter creator
 * @export
 */
export const TestReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMultipleS3File: async (projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling processMultipleS3File.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling processMultipleS3File.');
            }
            // verify required parameter 'uploadBatchFileResource' is not null or undefined
            if (uploadBatchFileResource === null || uploadBatchFileResource === undefined) {
                throw new RequiredError('uploadBatchFileResource','Required parameter uploadBatchFileResource was null or undefined when calling processMultipleS3File.');
            }
            const localVarPath = `/api/v1/katalon/test-reports/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof uploadBatchFileResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(uploadBatchFileResource !== undefined ? uploadBatchFileResource : {})
                : (uploadBatchFileResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processS3File: async (projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling processS3File.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling processS3File.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new RequiredError('folderPath','Required parameter folderPath was null or undefined when calling processS3File.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new RequiredError('isEnd','Required parameter isEnd was null or undefined when calling processS3File.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling processS3File.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling processS3File.');
            }
            const localVarPath = `/api/v1/katalon/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }

            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTestOpsReports: async (projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling processTestOpsReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling processTestOpsReports.');
            }
            // verify required parameter 'uploadBatchFileResource' is not null or undefined
            if (uploadBatchFileResource === null || uploadBatchFileResource === undefined) {
                throw new RequiredError('uploadBatchFileResource','Required parameter uploadBatchFileResource was null or undefined when calling processTestOpsReports.');
            }
            const localVarPath = `/api/v1/testops-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof uploadBatchFileResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(uploadBatchFileResource !== undefined ? uploadBatchFileResource : {})
                : (uploadBatchFileResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {TestRunResult} testRunResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult: async (projectId: number, testRunResult: TestRunResult, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling updateResult.');
            }
            // verify required parameter 'testRunResult' is not null or undefined
            if (testRunResult === null || testRunResult === undefined) {
                throw new RequiredError('testRunResult','Required parameter testRunResult was null or undefined when calling updateResult.');
            }
            const localVarPath = `/api/v1/katalon/test-reports/update-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof testRunResult !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(testRunResult !== undefined ? testRunResult : {})
                : (testRunResult || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadJUnitReports: async (projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, sessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new RequiredError('folderPath','Required parameter folderPath was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new RequiredError('isEnd','Required parameter isEnd was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling uploadJUnitReports.');
            }
            const localVarPath = `/api/v1/junit/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }

            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId 
         * @param {number} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {boolean} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTestNGReports: async (executionId: number, projectId: number, batch: string, folderPath: string, isEnd: boolean, fileName: string, uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'executionId' is not null or undefined
            if (executionId === null || executionId === undefined) {
                throw new RequiredError('executionId','Required parameter executionId was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new RequiredError('batch','Required parameter batch was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new RequiredError('folderPath','Required parameter folderPath was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new RequiredError('isEnd','Required parameter isEnd was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling uploadTestNGReports.');
            }
            const localVarPath = `/api/v1/testng/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }

            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestReportApi - functional programming interface
 * @export
 */
export const TestReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processMultipleS3File(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadBatchResource>>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processS3File(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadBatchResource>>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processTestOpsReports(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadBatchResource>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {TestRunResult} testRunResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResult(projectId: number, testRunResult: TestRunResult, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResource>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).updateResult(projectId, testRunResult, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadJUnitReports(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, sessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId 
         * @param {number} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {boolean} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTestNGReports(executionId: number, projectId: number, batch: string, folderPath: string, isEnd: boolean, fileName: string, uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TestReportApiAxiosParamCreator(configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestReportApi - factory interface
 * @export
 */
export const TestReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMultipleS3File(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any): AxiosPromise<Array<UploadBatchResource>> {
            return TestReportApiFp(configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processS3File(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, options?: any): AxiosPromise<Array<UploadBatchResource>> {
            return TestReportApiFp(configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId 
         * @param {string} batch 
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTestOpsReports(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any): AxiosPromise<UploadBatchResource> {
            return TestReportApiFp(configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} projectId 
         * @param {TestRunResult} testRunResult 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult(projectId: number, testRunResult: TestRunResult, options?: any): AxiosPromise<ExecutionResource> {
            return TestReportApiFp(configuration).updateResult(projectId, testRunResult, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {string} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadJUnitReports(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, sessionId?: string, options?: any): AxiosPromise<void> {
            return TestReportApiFp(configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId 
         * @param {number} projectId 
         * @param {string} batch 
         * @param {string} folderPath 
         * @param {boolean} isEnd 
         * @param {string} fileName 
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTestNGReports(executionId: number, projectId: number, batch: string, folderPath: string, isEnd: boolean, fileName: string, uploadedPath: string, options?: any): AxiosPromise<void> {
            return TestReportApiFp(configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestReportApi - object-oriented interface
 * @export
 * @class TestReportApi
 * @extends {BaseAPI}
 */
export class TestReportApi extends BaseAPI {
    /**
     * 
     * @summary Saves and processes multiple uploaded Katalon reports.
     * @param {number} projectId 
     * @param {string} batch 
     * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public processMultipleS3File(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any) {
        return TestReportApiFp(this.configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves and processes the uploaded Katalon reports.
     * @param {string} projectId 
     * @param {string} batch 
     * @param {string} folderPath 
     * @param {string} isEnd 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public processS3File(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, options?: any) {
        return TestReportApiFp(this.configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Saves and processes multiple uploaded TestOps reports.
     * @param {number} projectId 
     * @param {string} batch 
     * @param {Array<UploadBatchFileResource>} uploadBatchFileResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public processTestOpsReports(projectId: number, batch: string, uploadBatchFileResource: Array<UploadBatchFileResource>, options?: any) {
        return TestReportApiFp(this.configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} projectId 
     * @param {TestRunResult} testRunResult 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public updateResult(projectId: number, testRunResult: TestRunResult, options?: any) {
        return TestReportApiFp(this.configuration).updateResult(projectId, testRunResult, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads and processes the JUnit reports to an Execution.
     * @param {string} projectId 
     * @param {string} batch 
     * @param {string} folderPath 
     * @param {string} isEnd 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public uploadJUnitReports(projectId: string, batch: string, folderPath: string, isEnd: string, fileName: string, uploadedPath: string, sessionId?: string, options?: any) {
        return TestReportApiFp(this.configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads and processes the TestNG reports to an execution.
     * @param {number} executionId 
     * @param {number} projectId 
     * @param {string} batch 
     * @param {string} folderPath 
     * @param {boolean} isEnd 
     * @param {string} fileName 
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    public uploadTestNGReports(executionId: number, projectId: number, batch: string, folderPath: string, isEnd: boolean, fileName: string, uploadedPath: string, options?: any) {
        return TestReportApiFp(this.configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestSuiteApi - axios parameter creator
 * @export
 */
export const TestSuiteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get9: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get9.');
            }
            const localVarPath = `/api/v1/test-suites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestSuiteApi - functional programming interface
 * @export
 */
export const TestSuiteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get9(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestSuiteResource>> {
            const localVarAxiosArgs = await TestSuiteApiAxiosParamCreator(configuration).get9(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TestSuiteApi - factory interface
 * @export
 */
export const TestSuiteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns a Test Suite detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get9(id: string, options?: any): AxiosPromise<TestSuiteResource> {
            return TestSuiteApiFp(configuration).get9(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestSuiteApi - object-oriented interface
 * @export
 * @class TestSuiteApi
 * @extends {BaseAPI}
 */
export class TestSuiteApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Test Suite detail.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuiteApi
     */
    public get9(id: string, options?: any) {
        return TestSuiteApiFp(this.configuration).get9(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId 
         * @param {Array<number>} newUserIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserTeam: async (teamId: number, newUserIds: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling assignUserTeam.');
            }
            // verify required parameter 'newUserIds' is not null or undefined
            if (newUserIds === null || newUserIds === undefined) {
                throw new RequiredError('newUserIds','Required parameter newUserIds was null or undefined when calling assignUserTeam.');
            }
            const localVarPath = `/api/v1/users/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (newUserIds) {
                localVarQueryParameter['newUserIds'] = newUserIds;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAvatar: async (uploadedPath: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new RequiredError('uploadedPath','Required parameter uploadedPath was null or undefined when calling changeAvatar.');
            }
            const localVarPath = `/api/v1/users/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change name for current user.
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeName: async (firstName: string, lastName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'firstName' is not null or undefined
            if (firstName === null || firstName === undefined) {
                throw new RequiredError('firstName','Required parameter firstName was null or undefined when calling changeName.');
            }
            // verify required parameter 'lastName' is not null or undefined
            if (lastName === null || lastName === undefined) {
                throw new RequiredError('lastName','Required parameter lastName was null or undefined when calling changeName.');
            }
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate2: async (userSettingResource: UserSettingResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSettingResource' is not null or undefined
            if (userSettingResource === null || userSettingResource === undefined) {
                throw new RequiredError('userSettingResource','Required parameter userSettingResource was null or undefined when calling createOrUpdate2.');
            }
            const localVarPath = `/api/v1/user-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userSettingResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userSettingResource !== undefined ? userSettingResource : {})
                : (userSettingResource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAvatar: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get10: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (teamId: number, userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling removeUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling removeUser.');
            }
            const localVarPath = `/api/v1/users/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId 
         * @param {Array<number>} newUserIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignUserTeam(teamId: number, newUserIds: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResource>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).assignUserTeam(teamId, newUserIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAvatar(uploadedPath: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).changeAvatar(uploadedPath, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Change name for current user.
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeName(firstName: string, lastName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).changeName(firstName, lastName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdate2(userSettingResource: UserSettingResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createOrUpdate2(userSettingResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAvatar(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).downloadAvatar(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get10(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).get10(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getMe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(teamId: number, userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).removeUser(teamId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId 
         * @param {Array<number>} newUserIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserTeam(teamId: number, newUserIds: Array<number>, options?: any): AxiosPromise<Array<UserResource>> {
            return UserApiFp(configuration).assignUserTeam(teamId, newUserIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAvatar(uploadedPath: string, options?: any): AxiosPromise<UserResource> {
            return UserApiFp(configuration).changeAvatar(uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change name for current user.
         * @param {string} firstName 
         * @param {string} lastName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeName(firstName: string, lastName: string, options?: any): AxiosPromise<UserResource> {
            return UserApiFp(configuration).changeName(firstName, lastName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate2(userSettingResource: UserSettingResource, options?: any): AxiosPromise<UserSettingResource> {
            return UserApiFp(configuration).createOrUpdate2(userSettingResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAvatar(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).downloadAvatar(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get10(options?: any): AxiosPromise<UserSettingResource> {
            return UserApiFp(configuration).get10(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<UserResource> {
            return UserApiFp(configuration).getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(teamId: number, userId: number, options?: any): AxiosPromise<UserResource> {
            return UserApiFp(configuration).removeUser(teamId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Adds users to a Team. Returns the added User detail.
     * @param {number} teamId 
     * @param {Array<number>} newUserIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public assignUserTeam(teamId: number, newUserIds: Array<number>, options?: any) {
        return UserApiFp(this.configuration).assignUserTeam(teamId, newUserIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the avatar of the current User. Returns the updated User detail.
     * @param {string} uploadedPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changeAvatar(uploadedPath: string, options?: any) {
        return UserApiFp(this.configuration).changeAvatar(uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change name for current user.
     * @param {string} firstName 
     * @param {string} lastName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changeName(firstName: string, lastName: string, options?: any) {
        return UserApiFp(this.configuration).changeName(firstName, lastName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the User Settings detail. Returns the updated User Settings detail.
     * @param {UserSettingResource} userSettingResource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createOrUpdate2(userSettingResource: UserSettingResource, options?: any) {
        return UserApiFp(this.configuration).createOrUpdate2(userSettingResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads the avatar of the current User. Returns the current avatar file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public downloadAvatar(options?: any) {
        return UserApiFp(this.configuration).downloadAvatar(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the User Settings detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public get10(options?: any) {
        return UserApiFp(this.configuration).get10(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the current User detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: any) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Removes a User from a Team. Returns the removed User detail.
     * @param {number} teamId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeUser(teamId: number, userId: number, options?: any) {
        return UserApiFp(this.configuration).removeUser(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebServiceApi - axios parameter creator
 * @export
 */
export const WebServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Web Service detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get16: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling get16.');
            }
            const localVarPath = `/api/v1/test-objects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebServiceApi - functional programming interface
 * @export
 */
export const WebServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Web Service detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get16(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestObjectResource>> {
            const localVarAxiosArgs = await WebServiceApiAxiosParamCreator(configuration).get16(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WebServiceApi - factory interface
 * @export
 */
export const WebServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns a Web Service detail.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get16(id: string, options?: any): AxiosPromise<TestObjectResource> {
            return WebServiceApiFp(configuration).get16(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebServiceApi - object-oriented interface
 * @export
 * @class WebServiceApi
 * @extends {BaseAPI}
 */
export class WebServiceApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Web Service detail.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebServiceApi
     */
    public get16(id: string, options?: any) {
        return WebServiceApiFp(this.configuration).get16(id, options).then((request) => request(this.axios, this.basePath));
    }
}


