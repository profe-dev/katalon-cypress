"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Katalon TestOps API reference
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebServiceApi = exports.WebServiceApiFactory = exports.WebServiceApiFp = exports.WebServiceApiAxiosParamCreator = exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.TestSuiteApi = exports.TestSuiteApiFactory = exports.TestSuiteApiFp = exports.TestSuiteApiAxiosParamCreator = exports.TestReportApi = exports.TestReportApiFactory = exports.TestReportApiFp = exports.TestReportApiAxiosParamCreator = exports.TestProjectApi = exports.TestProjectApiFactory = exports.TestProjectApiFp = exports.TestProjectApiAxiosParamCreator = exports.TestPlanApi = exports.TestPlanApiFactory = exports.TestPlanApiFp = exports.TestPlanApiAxiosParamCreator = exports.TestObjectApi = exports.TestObjectApiFactory = exports.TestObjectApiFp = exports.TestObjectApiAxiosParamCreator = exports.TestCaseApi = exports.TestCaseApiFactory = exports.TestCaseApiFp = exports.TestCaseApiAxiosParamCreator = exports.TeamApi = exports.TeamApiFactory = exports.TeamApiFp = exports.TeamApiAxiosParamCreator = exports.TaskApi = exports.TaskApiFactory = exports.TaskApiFp = exports.TaskApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.ReleaseApi = exports.ReleaseApiFactory = exports.ReleaseApiFp = exports.ReleaseApiAxiosParamCreator = exports.ProjectConfigurationResourceControllerApi = exports.ProjectConfigurationResourceControllerApiFactory = exports.ProjectConfigurationResourceControllerApiFp = exports.ProjectConfigurationResourceControllerApiAxiosParamCreator = exports.ProjectApi = exports.ProjectApiFactory = exports.ProjectApiFp = exports.ProjectApiAxiosParamCreator = exports.OrganizationTrialRequestResourceControllerApi = exports.OrganizationTrialRequestResourceControllerApiFactory = exports.OrganizationTrialRequestResourceControllerApiFp = exports.OrganizationTrialRequestResourceControllerApiAxiosParamCreator = exports.KatalonRecorderApi = exports.KatalonRecorderApiFactory = exports.KatalonRecorderApiFp = exports.KatalonRecorderApiAxiosParamCreator = exports.JobApi = exports.JobApiFactory = exports.JobApiFp = exports.JobApiAxiosParamCreator = exports.FileApi = exports.FileApiFactory = exports.FileApiFp = exports.FileApiAxiosParamCreator = exports.ExecutionTestSuiteApi = exports.ExecutionTestSuiteApiFactory = exports.ExecutionTestSuiteApiFp = exports.ExecutionTestSuiteApiAxiosParamCreator = exports.ExecutionTestResultApi = exports.ExecutionTestResultApiFactory = exports.ExecutionTestResultApiFp = exports.ExecutionTestResultApiAxiosParamCreator = exports.ExecutionRequestApi = exports.ExecutionRequestApiFactory = exports.ExecutionRequestApiFp = exports.ExecutionRequestApiAxiosParamCreator = exports.ExecutionApi = exports.ExecutionApiFactory = exports.ExecutionApiFp = exports.ExecutionApiAxiosParamCreator = exports.CommentApi = exports.CommentApiFactory = exports.CommentApiFp = exports.CommentApiAxiosParamCreator = exports.AgentApi = exports.AgentApiFactory = exports.AgentApiFp = exports.AgentApiAxiosParamCreator = exports.UserTeamResourceRoleEnum = exports.UserResourceSystemRoleEnum = exports.UserOrganizationFeatureResourceFeatureEnum = exports.UploadFileResourceTypeEnum = exports.TriggerBuildParameterTypeEnum = exports.TriggerBuildParameterConfigTypeEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesMonthEnum = exports.TestProjectResourceTypeEnum = exports.TestCaseResourceTypeEnum = exports.TestCaseResourcePreviousStatusEnum = exports.TeamResourceRoleEnum = exports.SearchRequestSearchEntityEnum = exports.SchedulerResourceIntervalUnitEnum = exports.RunConfigurationResourceCloudTypeEnum = exports.RunConfigurationResourceConfigTypeEnum = exports.ProjectResourceStatusEnum = exports.ProjectConfigurationResourceNameEnum = exports.OrganizationTrialRequestResourceStatusEnum = exports.OrganizationResourceTestOpsPackageEnum = exports.OrganizationResourceRoleEnum = exports.K8SAgentResourceAuthenticationTypeEnum = exports.JobResourceNodeStatusEnum = exports.JobResourceTriggerByEnum = exports.JobResourceStatusEnum = exports.GitRepositoryResourceVcsTypeEnum = exports.ExecutionTestSuiteResourceStatusEnum = exports.ExecutionTestResultResourceFailedTestResultCategoryEnum = exports.ExecutionTestResultResourceStatusEnum = exports.ExecutionTestCaseResourceStatusEnum = exports.ExecutionResourceTypeEnum = exports.ExecutionResourceExecutionStageEnum = exports.ExecutionResourceStatusEnum = exports.CommentResourceObjectTypeEnum = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var CommentResourceObjectTypeEnum;
(function (CommentResourceObjectTypeEnum) {
    CommentResourceObjectTypeEnum["ExecutionTestSuite"] = "EXECUTION_TEST_SUITE";
    CommentResourceObjectTypeEnum["ExecutionTestResult"] = "EXECUTION_TEST_RESULT";
    CommentResourceObjectTypeEnum["TestCase"] = "TEST_CASE";
    CommentResourceObjectTypeEnum["Incident"] = "INCIDENT";
    CommentResourceObjectTypeEnum["KeyesExecution"] = "KEYES_EXECUTION";
})(CommentResourceObjectTypeEnum = exports.CommentResourceObjectTypeEnum || (exports.CommentResourceObjectTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionResourceStatusEnum;
(function (ExecutionResourceStatusEnum) {
    ExecutionResourceStatusEnum["Passed"] = "PASSED";
    ExecutionResourceStatusEnum["Failed"] = "FAILED";
    ExecutionResourceStatusEnum["Error"] = "ERROR";
    ExecutionResourceStatusEnum["Incomplete"] = "INCOMPLETE";
    ExecutionResourceStatusEnum["Running"] = "RUNNING";
    ExecutionResourceStatusEnum["Skipped"] = "SKIPPED";
    ExecutionResourceStatusEnum["NotRun"] = "NOT_RUN";
})(ExecutionResourceStatusEnum = exports.ExecutionResourceStatusEnum || (exports.ExecutionResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionResourceExecutionStageEnum;
(function (ExecutionResourceExecutionStageEnum) {
    ExecutionResourceExecutionStageEnum["Running"] = "RUNNING";
    ExecutionResourceExecutionStageEnum["Completed"] = "COMPLETED";
    ExecutionResourceExecutionStageEnum["Terminate"] = "TERMINATE";
    ExecutionResourceExecutionStageEnum["Analyzing"] = "ANALYZING";
    ExecutionResourceExecutionStageEnum["Analyzed"] = "ANALYZED";
    ExecutionResourceExecutionStageEnum["Importing"] = "IMPORTING";
    ExecutionResourceExecutionStageEnum["Error"] = "ERROR";
})(ExecutionResourceExecutionStageEnum = exports.ExecutionResourceExecutionStageEnum || (exports.ExecutionResourceExecutionStageEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionResourceTypeEnum;
(function (ExecutionResourceTypeEnum) {
    ExecutionResourceTypeEnum["Katalon"] = "KATALON";
    ExecutionResourceTypeEnum["Bdd"] = "BDD";
})(ExecutionResourceTypeEnum = exports.ExecutionResourceTypeEnum || (exports.ExecutionResourceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionTestCaseResourceStatusEnum;
(function (ExecutionTestCaseResourceStatusEnum) {
    ExecutionTestCaseResourceStatusEnum["Passed"] = "PASSED";
    ExecutionTestCaseResourceStatusEnum["Failed"] = "FAILED";
    ExecutionTestCaseResourceStatusEnum["Error"] = "ERROR";
    ExecutionTestCaseResourceStatusEnum["Incomplete"] = "INCOMPLETE";
    ExecutionTestCaseResourceStatusEnum["Running"] = "RUNNING";
    ExecutionTestCaseResourceStatusEnum["Skipped"] = "SKIPPED";
    ExecutionTestCaseResourceStatusEnum["NotRun"] = "NOT_RUN";
})(ExecutionTestCaseResourceStatusEnum = exports.ExecutionTestCaseResourceStatusEnum || (exports.ExecutionTestCaseResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionTestResultResourceStatusEnum;
(function (ExecutionTestResultResourceStatusEnum) {
    ExecutionTestResultResourceStatusEnum["Passed"] = "PASSED";
    ExecutionTestResultResourceStatusEnum["Failed"] = "FAILED";
    ExecutionTestResultResourceStatusEnum["Error"] = "ERROR";
    ExecutionTestResultResourceStatusEnum["Incomplete"] = "INCOMPLETE";
    ExecutionTestResultResourceStatusEnum["Running"] = "RUNNING";
    ExecutionTestResultResourceStatusEnum["Skipped"] = "SKIPPED";
    ExecutionTestResultResourceStatusEnum["NotRun"] = "NOT_RUN";
})(ExecutionTestResultResourceStatusEnum = exports.ExecutionTestResultResourceStatusEnum || (exports.ExecutionTestResultResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionTestResultResourceFailedTestResultCategoryEnum;
(function (ExecutionTestResultResourceFailedTestResultCategoryEnum) {
    ExecutionTestResultResourceFailedTestResultCategoryEnum["Application"] = "APPLICATION";
    ExecutionTestResultResourceFailedTestResultCategoryEnum["Automation"] = "AUTOMATION";
    ExecutionTestResultResourceFailedTestResultCategoryEnum["Environment"] = "ENVIRONMENT";
    ExecutionTestResultResourceFailedTestResultCategoryEnum["Unknown"] = "UNKNOWN";
})(ExecutionTestResultResourceFailedTestResultCategoryEnum = exports.ExecutionTestResultResourceFailedTestResultCategoryEnum || (exports.ExecutionTestResultResourceFailedTestResultCategoryEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ExecutionTestSuiteResourceStatusEnum;
(function (ExecutionTestSuiteResourceStatusEnum) {
    ExecutionTestSuiteResourceStatusEnum["Passed"] = "PASSED";
    ExecutionTestSuiteResourceStatusEnum["Failed"] = "FAILED";
    ExecutionTestSuiteResourceStatusEnum["Error"] = "ERROR";
    ExecutionTestSuiteResourceStatusEnum["Incomplete"] = "INCOMPLETE";
    ExecutionTestSuiteResourceStatusEnum["Running"] = "RUNNING";
    ExecutionTestSuiteResourceStatusEnum["Skipped"] = "SKIPPED";
    ExecutionTestSuiteResourceStatusEnum["NotRun"] = "NOT_RUN";
})(ExecutionTestSuiteResourceStatusEnum = exports.ExecutionTestSuiteResourceStatusEnum || (exports.ExecutionTestSuiteResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var GitRepositoryResourceVcsTypeEnum;
(function (GitRepositoryResourceVcsTypeEnum) {
    GitRepositoryResourceVcsTypeEnum["Github"] = "GITHUB";
    GitRepositoryResourceVcsTypeEnum["Gitlab"] = "GITLAB";
    GitRepositoryResourceVcsTypeEnum["Bitbucket"] = "BITBUCKET";
    GitRepositoryResourceVcsTypeEnum["Others"] = "OTHERS";
})(GitRepositoryResourceVcsTypeEnum = exports.GitRepositoryResourceVcsTypeEnum || (exports.GitRepositoryResourceVcsTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var JobResourceStatusEnum;
(function (JobResourceStatusEnum) {
    JobResourceStatusEnum["Queued"] = "QUEUED";
    JobResourceStatusEnum["Running"] = "RUNNING";
    JobResourceStatusEnum["Failed"] = "FAILED";
    JobResourceStatusEnum["Success"] = "SUCCESS";
    JobResourceStatusEnum["Canceled"] = "CANCELED";
    JobResourceStatusEnum["Error"] = "ERROR";
    JobResourceStatusEnum["WaitForTrigger"] = "WAIT_FOR_TRIGGER";
})(JobResourceStatusEnum = exports.JobResourceStatusEnum || (exports.JobResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var JobResourceTriggerByEnum;
(function (JobResourceTriggerByEnum) {
    JobResourceTriggerByEnum["Manual"] = "MANUAL";
    JobResourceTriggerByEnum["Schedule"] = "SCHEDULE";
})(JobResourceTriggerByEnum = exports.JobResourceTriggerByEnum || (exports.JobResourceTriggerByEnum = {}));
/**
    * @export
    * @enum {string}
    */
var JobResourceNodeStatusEnum;
(function (JobResourceNodeStatusEnum) {
    JobResourceNodeStatusEnum["PendingCanceled"] = "PENDING_CANCELED";
    JobResourceNodeStatusEnum["Canceled"] = "CANCELED";
})(JobResourceNodeStatusEnum = exports.JobResourceNodeStatusEnum || (exports.JobResourceNodeStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var K8SAgentResourceAuthenticationTypeEnum;
(function (K8SAgentResourceAuthenticationTypeEnum) {
    K8SAgentResourceAuthenticationTypeEnum["BasicAuth"] = "BASIC_AUTH";
    K8SAgentResourceAuthenticationTypeEnum["BearerToken"] = "BEARER_TOKEN";
    K8SAgentResourceAuthenticationTypeEnum["EksAuth"] = "EKS_AUTH";
})(K8SAgentResourceAuthenticationTypeEnum = exports.K8SAgentResourceAuthenticationTypeEnum || (exports.K8SAgentResourceAuthenticationTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var OrganizationResourceRoleEnum;
(function (OrganizationResourceRoleEnum) {
    OrganizationResourceRoleEnum["Owner"] = "OWNER";
    OrganizationResourceRoleEnum["Admin"] = "ADMIN";
    OrganizationResourceRoleEnum["User"] = "USER";
    OrganizationResourceRoleEnum["BillingManager"] = "BILLING_MANAGER";
})(OrganizationResourceRoleEnum = exports.OrganizationResourceRoleEnum || (exports.OrganizationResourceRoleEnum = {}));
/**
    * @export
    * @enum {string}
    */
var OrganizationResourceTestOpsPackageEnum;
(function (OrganizationResourceTestOpsPackageEnum) {
    OrganizationResourceTestOpsPackageEnum["Basic"] = "BASIC";
    OrganizationResourceTestOpsPackageEnum["Advanced"] = "ADVANCED";
    OrganizationResourceTestOpsPackageEnum["Enterprise"] = "ENTERPRISE";
})(OrganizationResourceTestOpsPackageEnum = exports.OrganizationResourceTestOpsPackageEnum || (exports.OrganizationResourceTestOpsPackageEnum = {}));
/**
    * @export
    * @enum {string}
    */
var OrganizationTrialRequestResourceStatusEnum;
(function (OrganizationTrialRequestResourceStatusEnum) {
    OrganizationTrialRequestResourceStatusEnum["Pending"] = "PENDING";
    OrganizationTrialRequestResourceStatusEnum["Approved"] = "APPROVED";
    OrganizationTrialRequestResourceStatusEnum["Rejected"] = "REJECTED";
})(OrganizationTrialRequestResourceStatusEnum = exports.OrganizationTrialRequestResourceStatusEnum || (exports.OrganizationTrialRequestResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ProjectConfigurationResourceNameEnum;
(function (ProjectConfigurationResourceNameEnum) {
    ProjectConfigurationResourceNameEnum["Timezone"] = "TIMEZONE";
    ProjectConfigurationResourceNameEnum["AssertionPattern"] = "ASSERTION_PATTERN";
})(ProjectConfigurationResourceNameEnum = exports.ProjectConfigurationResourceNameEnum || (exports.ProjectConfigurationResourceNameEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ProjectResourceStatusEnum;
(function (ProjectResourceStatusEnum) {
    ProjectResourceStatusEnum["Archive"] = "ARCHIVE";
    ProjectResourceStatusEnum["Active"] = "ACTIVE";
})(ProjectResourceStatusEnum = exports.ProjectResourceStatusEnum || (exports.ProjectResourceStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var RunConfigurationResourceConfigTypeEnum;
(function (RunConfigurationResourceConfigTypeEnum) {
    RunConfigurationResourceConfigTypeEnum["Tsc"] = "TSC";
    RunConfigurationResourceConfigTypeEnum["Command"] = "COMMAND";
    RunConfigurationResourceConfigTypeEnum["GenericCommand"] = "GENERIC_COMMAND";
})(RunConfigurationResourceConfigTypeEnum = exports.RunConfigurationResourceConfigTypeEnum || (exports.RunConfigurationResourceConfigTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var RunConfigurationResourceCloudTypeEnum;
(function (RunConfigurationResourceCloudTypeEnum) {
    RunConfigurationResourceCloudTypeEnum["K8S"] = "K8S";
    RunConfigurationResourceCloudTypeEnum["LocalAgent"] = "LOCAL_AGENT";
    RunConfigurationResourceCloudTypeEnum["K8SAgent"] = "K8S_AGENT";
    RunConfigurationResourceCloudTypeEnum["CircleCiAgent"] = "CIRCLE_CI_AGENT";
})(RunConfigurationResourceCloudTypeEnum = exports.RunConfigurationResourceCloudTypeEnum || (exports.RunConfigurationResourceCloudTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SchedulerResourceIntervalUnitEnum;
(function (SchedulerResourceIntervalUnitEnum) {
    SchedulerResourceIntervalUnitEnum["Minute"] = "MINUTE";
    SchedulerResourceIntervalUnitEnum["Hour"] = "HOUR";
    SchedulerResourceIntervalUnitEnum["Day"] = "DAY";
    SchedulerResourceIntervalUnitEnum["Week"] = "WEEK";
    SchedulerResourceIntervalUnitEnum["Month"] = "MONTH";
})(SchedulerResourceIntervalUnitEnum = exports.SchedulerResourceIntervalUnitEnum || (exports.SchedulerResourceIntervalUnitEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SearchRequestSearchEntityEnum;
(function (SearchRequestSearchEntityEnum) {
    SearchRequestSearchEntityEnum["Execution"] = "Execution";
    SearchRequestSearchEntityEnum["ExecutionTestSuite"] = "ExecutionTestSuite";
    SearchRequestSearchEntityEnum["ExecutionStatistics"] = "ExecutionStatistics";
    SearchRequestSearchEntityEnum["ExecutionTestModule"] = "ExecutionTestModule";
    SearchRequestSearchEntityEnum["ExecutionTestResult"] = "ExecutionTestResult";
    SearchRequestSearchEntityEnum["ExecutionRequest"] = "ExecutionRequest";
    SearchRequestSearchEntityEnum["Incident"] = "Incident";
    SearchRequestSearchEntityEnum["TestCase"] = "TestCase";
    SearchRequestSearchEntityEnum["TestSuite"] = "TestSuite";
    SearchRequestSearchEntityEnum["ExecutionTestStep"] = "ExecutionTestStep";
    SearchRequestSearchEntityEnum["TestProject"] = "TestProject";
    SearchRequestSearchEntityEnum["Job"] = "Job";
    SearchRequestSearchEntityEnum["RunningTestRun"] = "RunningTestRun";
    SearchRequestSearchEntityEnum["Project"] = "Project";
    SearchRequestSearchEntityEnum["ApiKey"] = "ApiKey";
    SearchRequestSearchEntityEnum["Comment"] = "Comment";
    SearchRequestSearchEntityEnum["Team"] = "Team";
    SearchRequestSearchEntityEnum["Organization"] = "Organization";
    SearchRequestSearchEntityEnum["UserOrganization"] = "UserOrganization";
    SearchRequestSearchEntityEnum["UserTeam"] = "UserTeam";
    SearchRequestSearchEntityEnum["UserInvitation"] = "UserInvitation";
    SearchRequestSearchEntityEnum["UserSsoInvitation"] = "UserSsoInvitation";
    SearchRequestSearchEntityEnum["UserConfiguration"] = "UserConfiguration";
    SearchRequestSearchEntityEnum["Agent"] = "Agent";
    SearchRequestSearchEntityEnum["RunConfiguration"] = "RunConfiguration";
    SearchRequestSearchEntityEnum["Release"] = "Release";
    SearchRequestSearchEntityEnum["TestObject"] = "TestObject";
    SearchRequestSearchEntityEnum["TestObjectEntity"] = "TestObjectEntity";
    SearchRequestSearchEntityEnum["TestCaseExecution"] = "TestCaseExecution";
    SearchRequestSearchEntityEnum["TestCaseExecutionStatus"] = "TestCaseExecutionStatus";
    SearchRequestSearchEntityEnum["ReleaseStatisticsStatus"] = "ReleaseStatisticsStatus";
    SearchRequestSearchEntityEnum["TestCaseExecutionComparison"] = "TestCaseExecutionComparison";
    SearchRequestSearchEntityEnum["TestCaseExecutionComparisonStatistics"] = "TestCaseExecutionComparisonStatistics";
    SearchRequestSearchEntityEnum["TestCasePlatformStatistics"] = "TestCasePlatformStatistics";
    SearchRequestSearchEntityEnum["Scheduler"] = "Scheduler";
    SearchRequestSearchEntityEnum["ExecutionAnalysis"] = "ExecutionAnalysis";
    SearchRequestSearchEntityEnum["ExecutionTestResultCategory"] = "ExecutionTestResultCategory";
    SearchRequestSearchEntityEnum["ExecutionTestResultGroup"] = "ExecutionTestResultGroup";
    SearchRequestSearchEntityEnum["ExecutionTestResultTestObjectEntity"] = "ExecutionTestResultTestObjectEntity";
    SearchRequestSearchEntityEnum["ExecutionFile"] = "ExecutionFile";
    SearchRequestSearchEntityEnum["TestSuiteCollection"] = "TestSuiteCollection";
    SearchRequestSearchEntityEnum["TestSuiteCollectionEntity"] = "TestSuiteCollectionEntity";
    SearchRequestSearchEntityEnum["TestCasePriority"] = "TestCasePriority";
    SearchRequestSearchEntityEnum["ExternalConnection"] = "ExternalConnection";
    SearchRequestSearchEntityEnum["PlatformStatistics"] = "PlatformStatistics";
    SearchRequestSearchEntityEnum["TestProjectFile"] = "TestProjectFile";
    SearchRequestSearchEntityEnum["ProjectStatistics"] = "ProjectStatistics";
    SearchRequestSearchEntityEnum["ProjectRequirementStatistic"] = "ProjectRequirementStatistic";
    SearchRequestSearchEntityEnum["TestCaseRequirementStatistic"] = "TestCaseRequirementStatistic";
    SearchRequestSearchEntityEnum["UserOrganizationFeature"] = "UserOrganizationFeature";
    SearchRequestSearchEntityEnum["Machine"] = "Machine";
    SearchRequestSearchEntityEnum["LicenseKey"] = "LicenseKey";
    SearchRequestSearchEntityEnum["K8SAgent"] = "K8SAgent";
    SearchRequestSearchEntityEnum["CircleCiAgent"] = "CircleCiAgent";
    SearchRequestSearchEntityEnum["JobSummary"] = "JobSummary";
    SearchRequestSearchEntityEnum["KatalonRecorderBackup"] = "KatalonRecorderBackup";
    SearchRequestSearchEntityEnum["ExternalDefect"] = "ExternalDefect";
    SearchRequestSearchEntityEnum["ExternalRequirement"] = "ExternalRequirement";
    SearchRequestSearchEntityEnum["ExternalTraceability"] = "ExternalTraceability";
    SearchRequestSearchEntityEnum["RequirementTestRunCoverage"] = "RequirementTestRunCoverage";
    SearchRequestSearchEntityEnum["WhitelistIp"] = "WhitelistIp";
    SearchRequestSearchEntityEnum["KsSession"] = "KsSession";
    SearchRequestSearchEntityEnum["CiDashboardStatistics"] = "CiDashboardStatistics";
    SearchRequestSearchEntityEnum["Checkpoint"] = "Checkpoint";
    SearchRequestSearchEntityEnum["KeyesExecution"] = "KeyesExecution";
    SearchRequestSearchEntityEnum["RecentProject"] = "RecentProject";
    SearchRequestSearchEntityEnum["JiraIssue"] = "JiraIssue";
    SearchRequestSearchEntityEnum["SlackConnection"] = "SlackConnection";
    SearchRequestSearchEntityEnum["Baseline"] = "Baseline";
    SearchRequestSearchEntityEnum["BaselineCollection"] = "BaselineCollection";
    SearchRequestSearchEntityEnum["TestCaseFlakiness"] = "TestCaseFlakiness";
})(SearchRequestSearchEntityEnum = exports.SearchRequestSearchEntityEnum || (exports.SearchRequestSearchEntityEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TeamResourceRoleEnum;
(function (TeamResourceRoleEnum) {
    TeamResourceRoleEnum["Owner"] = "OWNER";
    TeamResourceRoleEnum["Admin"] = "ADMIN";
    TeamResourceRoleEnum["User"] = "USER";
})(TeamResourceRoleEnum = exports.TeamResourceRoleEnum || (exports.TeamResourceRoleEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TestCaseResourcePreviousStatusEnum;
(function (TestCaseResourcePreviousStatusEnum) {
    TestCaseResourcePreviousStatusEnum["Passed"] = "PASSED";
    TestCaseResourcePreviousStatusEnum["Failed"] = "FAILED";
    TestCaseResourcePreviousStatusEnum["Error"] = "ERROR";
    TestCaseResourcePreviousStatusEnum["Incomplete"] = "INCOMPLETE";
    TestCaseResourcePreviousStatusEnum["Running"] = "RUNNING";
    TestCaseResourcePreviousStatusEnum["Skipped"] = "SKIPPED";
    TestCaseResourcePreviousStatusEnum["NotRun"] = "NOT_RUN";
})(TestCaseResourcePreviousStatusEnum = exports.TestCaseResourcePreviousStatusEnum || (exports.TestCaseResourcePreviousStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TestCaseResourceTypeEnum;
(function (TestCaseResourceTypeEnum) {
    TestCaseResourceTypeEnum["TestCase"] = "TEST_CASE";
    TestCaseResourceTypeEnum["Scenario"] = "SCENARIO";
})(TestCaseResourceTypeEnum = exports.TestCaseResourceTypeEnum || (exports.TestCaseResourceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TestProjectResourceTypeEnum;
(function (TestProjectResourceTypeEnum) {
    TestProjectResourceTypeEnum["Ks"] = "KS";
    TestProjectResourceTypeEnum["Git"] = "GIT";
})(TestProjectResourceTypeEnum = exports.TestProjectResourceTypeEnum || (exports.TestProjectResourceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TimeZoneResourceOffsetRulesTransitionRulesMonthEnum;
(function (TimeZoneResourceOffsetRulesTransitionRulesMonthEnum) {
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["January"] = "JANUARY";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["February"] = "FEBRUARY";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["March"] = "MARCH";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["April"] = "APRIL";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["May"] = "MAY";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["June"] = "JUNE";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["July"] = "JULY";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["August"] = "AUGUST";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["September"] = "SEPTEMBER";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["October"] = "OCTOBER";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["November"] = "NOVEMBER";
    TimeZoneResourceOffsetRulesTransitionRulesMonthEnum["December"] = "DECEMBER";
})(TimeZoneResourceOffsetRulesTransitionRulesMonthEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesMonthEnum || (exports.TimeZoneResourceOffsetRulesTransitionRulesMonthEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum;
(function (TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum) {
    TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum["Utc"] = "UTC";
    TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum["Wall"] = "WALL";
    TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum["Standard"] = "STANDARD";
})(TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum || (exports.TimeZoneResourceOffsetRulesTransitionRulesTimeDefinitionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum;
(function (TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum) {
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Monday"] = "MONDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Tuesday"] = "TUESDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Wednesday"] = "WEDNESDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Thursday"] = "THURSDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Friday"] = "FRIDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Saturday"] = "SATURDAY";
    TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum["Sunday"] = "SUNDAY";
})(TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum = exports.TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum || (exports.TimeZoneResourceOffsetRulesTransitionRulesDayOfWeekEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TriggerBuildParameterConfigTypeEnum;
(function (TriggerBuildParameterConfigTypeEnum) {
    TriggerBuildParameterConfigTypeEnum["Tsc"] = "TSC";
    TriggerBuildParameterConfigTypeEnum["Command"] = "COMMAND";
    TriggerBuildParameterConfigTypeEnum["GenericCommand"] = "GENERIC_COMMAND";
})(TriggerBuildParameterConfigTypeEnum = exports.TriggerBuildParameterConfigTypeEnum || (exports.TriggerBuildParameterConfigTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TriggerBuildParameterTypeEnum;
(function (TriggerBuildParameterTypeEnum) {
    TriggerBuildParameterTypeEnum["Ks"] = "KS";
    TriggerBuildParameterTypeEnum["Git"] = "GIT";
})(TriggerBuildParameterTypeEnum = exports.TriggerBuildParameterTypeEnum || (exports.TriggerBuildParameterTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var UploadFileResourceTypeEnum;
(function (UploadFileResourceTypeEnum) {
    UploadFileResourceTypeEnum["TscExecution"] = "TSC_EXECUTION";
    UploadFileResourceTypeEnum["TsExecution"] = "TS_EXECUTION";
    UploadFileResourceTypeEnum["Attachment"] = "ATTACHMENT";
    UploadFileResourceTypeEnum["Properties"] = "PROPERTIES";
    UploadFileResourceTypeEnum["Har"] = "HAR";
    UploadFileResourceTypeEnum["Uuid"] = "UUID";
    UploadFileResourceTypeEnum["Zip"] = "ZIP";
    UploadFileResourceTypeEnum["Bdd"] = "BDD";
    UploadFileResourceTypeEnum["TestopsReportMetadata"] = "TESTOPS_REPORT_METADATA";
    UploadFileResourceTypeEnum["TestopsReportExecution"] = "TESTOPS_REPORT_EXECUTION";
    UploadFileResourceTypeEnum["TestopsReportSuites"] = "TESTOPS_REPORT_SUITES";
    UploadFileResourceTypeEnum["TestopsReportResults"] = "TESTOPS_REPORT_RESULTS";
})(UploadFileResourceTypeEnum = exports.UploadFileResourceTypeEnum || (exports.UploadFileResourceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var UserOrganizationFeatureResourceFeatureEnum;
(function (UserOrganizationFeatureResourceFeatureEnum) {
    UserOrganizationFeatureResourceFeatureEnum["Kse"] = "KSE";
    UserOrganizationFeatureResourceFeatureEnum["Engine"] = "ENGINE";
    UserOrganizationFeatureResourceFeatureEnum["Testops"] = "TESTOPS";
    UserOrganizationFeatureResourceFeatureEnum["FloatingEngine"] = "FLOATING_ENGINE";
    UserOrganizationFeatureResourceFeatureEnum["UnlimitedKse"] = "UNLIMITED_KSE";
    UserOrganizationFeatureResourceFeatureEnum["UnlimitedEngine"] = "UNLIMITED_ENGINE";
})(UserOrganizationFeatureResourceFeatureEnum = exports.UserOrganizationFeatureResourceFeatureEnum || (exports.UserOrganizationFeatureResourceFeatureEnum = {}));
/**
    * @export
    * @enum {string}
    */
var UserResourceSystemRoleEnum;
(function (UserResourceSystemRoleEnum) {
    UserResourceSystemRoleEnum["User"] = "USER";
    UserResourceSystemRoleEnum["KatalonAdmin"] = "KATALON_ADMIN";
})(UserResourceSystemRoleEnum = exports.UserResourceSystemRoleEnum || (exports.UserResourceSystemRoleEnum = {}));
/**
    * @export
    * @enum {string}
    */
var UserTeamResourceRoleEnum;
(function (UserTeamResourceRoleEnum) {
    UserTeamResourceRoleEnum["Owner"] = "OWNER";
    UserTeamResourceRoleEnum["Admin"] = "ADMIN";
    UserTeamResourceRoleEnum["User"] = "USER";
})(UserTeamResourceRoleEnum = exports.UserTeamResourceRoleEnum || (exports.UserTeamResourceRoleEnum = {}));
/**
 * AgentApi - axios parameter creator
 * @export
 */
exports.AgentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/v1/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: (agentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentResource' is not null or undefined
            if (agentResource === null || agentResource === undefined) {
                throw new base_1.RequiredError('agentResource', 'Required parameter agentResource was null or undefined when calling create.');
            }
            const localVarPath = `/api/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof agentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(agentResource !== undefined ? agentResource : {})
                : (agentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: (circleCIAgentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'circleCIAgentResource' is not null or undefined
            if (circleCIAgentResource === null || circleCIAgentResource === undefined) {
                throw new base_1.RequiredError('circleCIAgentResource', 'Required parameter circleCIAgentResource was null or undefined when calling create4.');
            }
            const localVarPath = `/api/v1/circle-ci-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof circleCIAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(circleCIAgentResource !== undefined ? circleCIAgentResource : {})
                : (circleCIAgentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: (k8SAgentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'k8SAgentResource' is not null or undefined
            if (k8SAgentResource === null || k8SAgentResource === undefined) {
                throw new base_1.RequiredError('k8SAgentResource', 'Required parameter k8SAgentResource was null or undefined when calling create5.');
            }
            const localVarPath = `/api/v1/k8s-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof k8SAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(k8SAgentResource !== undefined ? k8SAgentResource : {})
                : (k8SAgentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAgent: (agentConfigResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentConfigResource' is not null or undefined
            if (agentConfigResource === null || agentConfigResource === undefined) {
                throw new base_1.RequiredError('agentConfigResource', 'Required parameter agentConfigResource was null or undefined when calling generateAgent.');
            }
            const localVarPath = `/api/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (agentConfigResource !== undefined) {
                localVarQueryParameter['agentConfigResource'] = agentConfigResource;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get.');
            }
            const localVarPath = `/api/v1/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a CircleCI agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get11: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get11.');
            }
            const localVarPath = `/api/v1/circle-ci-agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a K8S agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get13: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get13.');
            }
            const localVarPath = `/api/v1/k8s-agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CircleCIConnectionResource} circleCIConnectionResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedProjects: (circleCIConnectionResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'circleCIConnectionResource' is not null or undefined
            if (circleCIConnectionResource === null || circleCIConnectionResource === undefined) {
                throw new base_1.RequiredError('circleCIConnectionResource', 'Required parameter circleCIConnectionResource was null or undefined when calling getFollowedProjects.');
            }
            const localVarPath = `/api/v1/circle-ci-agent/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof circleCIConnectionResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(circleCIConnectionResource !== undefined ? circleCIConnectionResource : {})
                : (circleCIConnectionResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6: (circleCIAgentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'circleCIAgentResource' is not null or undefined
            if (circleCIAgentResource === null || circleCIAgentResource === undefined) {
                throw new base_1.RequiredError('circleCIAgentResource', 'Required parameter circleCIAgentResource was null or undefined when calling update6.');
            }
            const localVarPath = `/api/v1/circle-ci-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof circleCIAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(circleCIAgentResource !== undefined ? circleCIAgentResource : {})
                : (circleCIAgentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7: (k8SAgentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'k8SAgentResource' is not null or undefined
            if (k8SAgentResource === null || k8SAgentResource === undefined) {
                throw new base_1.RequiredError('k8SAgentResource', 'Required parameter k8SAgentResource was null or undefined when calling update7.');
            }
            const localVarPath = `/api/v1/k8s-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof k8SAgentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(k8SAgentResource !== undefined ? k8SAgentResource : {})
                : (k8SAgentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThreshold: (agentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'agentResource' is not null or undefined
            if (agentResource === null || agentResource === undefined) {
                throw new base_1.RequiredError('agentResource', 'Required parameter agentResource was null or undefined when calling updateThreshold.');
            }
            const localVarPath = `/api/v1/agent/threshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof agentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(agentResource !== undefined ? agentResource : {})
                : (agentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AgentApi - functional programming interface
 * @export
 */
exports.AgentApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration)._delete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(agentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).create(agentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(circleCIAgentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).create4(circleCIAgentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(k8SAgentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).create5(k8SAgentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAgent(agentConfigResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).generateAgent(agentConfigResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).get(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a CircleCI agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get11(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).get11(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a K8S agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get13(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).get13(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {CircleCIConnectionResource} circleCIConnectionResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedProjects(circleCIConnectionResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).getFollowedProjects(circleCIConnectionResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6(circleCIAgentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).update6(circleCIAgentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7(k8SAgentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).update7(k8SAgentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThreshold(agentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AgentApiAxiosParamCreator(configuration).updateThreshold(agentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AgentApi - factory interface
 * @export
 */
exports.AgentApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Deletes a Local agent. Returns the deleted agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id, options) {
            return exports.AgentApiFp(configuration)._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates or updates a Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(agentResource, options) {
            return exports.AgentApiFp(configuration).create(agentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new CircleCI agent. Returns the created agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(circleCIAgentResource, options) {
            return exports.AgentApiFp(configuration).create4(circleCIAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a K8S agent. Returns the created agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(k8SAgentResource, options) {
            return exports.AgentApiFp(configuration).create5(k8SAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generates the configuration file for the Local agent. Returns the configuration file.
         * @param {AgentConfigResource} agentConfigResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAgent(agentConfigResource, options) {
            return exports.AgentApiFp(configuration).generateAgent(agentConfigResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Local agent. Returns the agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(id, options) {
            return exports.AgentApiFp(configuration).get(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a CircleCI agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get11(id, options) {
            return exports.AgentApiFp(configuration).get11(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a K8S agent detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get13(id, options) {
            return exports.AgentApiFp(configuration).get13(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CircleCIConnectionResource} circleCIConnectionResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedProjects(circleCIConnectionResource, options) {
            return exports.AgentApiFp(configuration).getFollowedProjects(circleCIConnectionResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
         * @param {CircleCIAgentResource} circleCIAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update6(circleCIAgentResource, options) {
            return exports.AgentApiFp(configuration).update6(circleCIAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a K8S agent detail. Returns the updated agent detail.
         * @param {K8SAgentResource} k8SAgentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update7(k8SAgentResource, options) {
            return exports.AgentApiFp(configuration).update7(k8SAgentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the threshold for Local agent. Returns the agent detail.
         * @param {AgentResource} agentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThreshold(agentResource, options) {
            return exports.AgentApiFp(configuration).updateThreshold(agentResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AgentApi - object-oriented interface
 * @export
 * @class AgentApi
 * @extends {BaseAPI}
 */
class AgentApi extends base_1.BaseAPI {
    /**
     *
     * @summary Deletes a Local agent. Returns the deleted agent detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    _delete(id, options) {
        return exports.AgentApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates or updates a Local agent. Returns the agent detail.
     * @param {AgentResource} agentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    create(agentResource, options) {
        return exports.AgentApiFp(this.configuration).create(agentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new CircleCI agent. Returns the created agent detail.
     * @param {CircleCIAgentResource} circleCIAgentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    create4(circleCIAgentResource, options) {
        return exports.AgentApiFp(this.configuration).create4(circleCIAgentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a K8S agent. Returns the created agent detail.
     * @param {K8SAgentResource} k8SAgentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    create5(k8SAgentResource, options) {
        return exports.AgentApiFp(this.configuration).create5(k8SAgentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Generates the configuration file for the Local agent. Returns the configuration file.
     * @param {AgentConfigResource} agentConfigResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    generateAgent(agentConfigResource, options) {
        return exports.AgentApiFp(this.configuration).generateAgent(agentConfigResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Local agent. Returns the agent detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    get(id, options) {
        return exports.AgentApiFp(this.configuration).get(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a CircleCI agent detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    get11(id, options) {
        return exports.AgentApiFp(this.configuration).get11(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a K8S agent detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    get13(id, options) {
        return exports.AgentApiFp(this.configuration).get13(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CircleCIConnectionResource} circleCIConnectionResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    getFollowedProjects(circleCIConnectionResource, options) {
        return exports.AgentApiFp(this.configuration).getFollowedProjects(circleCIConnectionResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a CircleCI agent detail. Returns the updated agent detail.
     * @param {CircleCIAgentResource} circleCIAgentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    update6(circleCIAgentResource, options) {
        return exports.AgentApiFp(this.configuration).update6(circleCIAgentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a K8S agent detail. Returns the updated agent detail.
     * @param {K8SAgentResource} k8SAgentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    update7(k8SAgentResource, options) {
        return exports.AgentApiFp(this.configuration).update7(k8SAgentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the threshold for Local agent. Returns the agent detail.
     * @param {AgentResource} agentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    updateThreshold(agentResource, options) {
        return exports.AgentApiFp(this.configuration).updateThreshold(agentResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AgentApi = AgentApi;
/**
 * CommentApi - axios parameter creator
 * @export
 */
exports.CommentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: (commentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'commentResource' is not null or undefined
            if (commentResource === null || commentResource === undefined) {
                throw new base_1.RequiredError('commentResource', 'Required parameter commentResource was null or undefined when calling create1.');
            }
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof commentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(commentResource !== undefined ? commentResource : {})
                : (commentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (commentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'commentResource' is not null or undefined
            if (commentResource === null || commentResource === undefined) {
                throw new base_1.RequiredError('commentResource', 'Required parameter commentResource was null or undefined when calling update.');
            }
            const localVarPath = `/api/v1/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof commentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(commentResource !== undefined ? commentResource : {})
                : (commentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CommentApi - functional programming interface
 * @export
 */
exports.CommentApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(commentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CommentApiAxiosParamCreator(configuration).create1(commentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(commentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CommentApiAxiosParamCreator(configuration).update(commentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CommentApi - factory interface
 * @export
 */
exports.CommentApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates a Comment. Returns the created Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(commentResource, options) {
            return exports.CommentApiFp(configuration).create1(commentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Comment detail. Returns the updated Comment detail.
         * @param {CommentResource} commentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(commentResource, options) {
            return exports.CommentApiFp(configuration).update(commentResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
class CommentApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a Comment. Returns the created Comment detail.
     * @param {CommentResource} commentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    create1(commentResource, options) {
        return exports.CommentApiFp(this.configuration).create1(commentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Comment detail. Returns the updated Comment detail.
     * @param {CommentResource} commentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    update(commentResource, options) {
        return exports.CommentApiFp(this.configuration).update(commentResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CommentApi = CommentApi;
/**
 * ExecutionApi - axios parameter creator
 * @export
 */
exports.ExecutionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id
         * @param {number} projectId
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload: (id, projectId, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling bulkDownload.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling bulkDownload.');
            }
            const localVarPath = `/api/v1/executions/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId
         * @param {Array<number>} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: (projectId, order, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling delete1.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new base_1.RequiredError('order', 'Required parameter order was null or undefined when calling delete1.');
            }
            const localVarPath = `/api/v1/executions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (order) {
                localVarQueryParameter['order'] = order;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1: (id, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling download1.');
            }
            const localVarPath = `/api/v1/executions/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/api/v1/executions/{id}/download-file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns an Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get1.');
            }
            const localVarPath = `/api/v1/executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExecutions: (id, pageable, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getLatestExecutions.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getLatestExecutions.');
            }
            const localVarPath = `/api/v1/organizations/{id}/latest-executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease: (id, projectId, releaseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling linkRelease.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling linkRelease.');
            }
            // verify required parameter 'releaseId' is not null or undefined
            if (releaseId === null || releaseId === undefined) {
                throw new base_1.RequiredError('releaseId', 'Required parameter releaseId was null or undefined when calling linkRelease.');
            }
            const localVarPath = `/api/v1/executions/{id}/link-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (releaseId !== undefined) {
                localVarQueryParameter['releaseId'] = releaseId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Pageable} pageable
         * @param {string} [batch]
         * @param {number} [projectId]
         * @param {number} [order]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: (pageable, batch, projectId, order, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling list.');
            }
            const localVarPath = `/api/v1/executions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reImportExecution: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling reImportExecution.');
            }
            const localVarPath = `/api/v1/executions/reimport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Rerun an Execution.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunExecution: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling rerunExecution.');
            }
            const localVarPath = `/api/v1/executions/{id}/rerun`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id
         * @param {ExecutionShareReportResource} executionShareReportResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareExecutionReport: (id, executionShareReportResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling shareExecutionReport.');
            }
            // verify required parameter 'executionShareReportResource' is not null or undefined
            if (executionShareReportResource === null || executionShareReportResource === undefined) {
                throw new base_1.RequiredError('executionShareReportResource', 'Required parameter executionShareReportResource was null or undefined when calling shareExecutionReport.');
            }
            const localVarPath = `/api/v1/executions/{id}/share-report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof executionShareReportResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(executionShareReportResource !== undefined ? executionShareReportResource : {})
                : (executionShareReportResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId
         * @param {number} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatedExecution: (projectId, order, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling terminatedExecution.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new base_1.RequiredError('order', 'Required parameter order was null or undefined when calling terminatedExecution.');
            }
            const localVarPath = `/api/v1/executions/terminate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling unlinkRelease.');
            }
            const localVarPath = `/api/v1/executions/{id}/unlink-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExecutionApi - functional programming interface
 * @export
 */
exports.ExecutionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id
         * @param {number} projectId
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload(id, projectId, fileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).bulkDownload(id, projectId, fileType, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId
         * @param {Array<number>} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(projectId, order, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).delete1(projectId, order, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1(id, fileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).download1(id, fileType, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).downloadFile(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns an Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).get1(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExecutions(id, pageable, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).getLatestExecutions(id, pageable, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease(id, projectId, releaseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).linkRelease(id, projectId, releaseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {Pageable} pageable
         * @param {string} [batch]
         * @param {number} [projectId]
         * @param {number} [order]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pageable, batch, projectId, order, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).list(pageable, batch, projectId, order, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reImportExecution(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).reImportExecution(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Rerun an Execution.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunExecution(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).rerunExecution(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id
         * @param {ExecutionShareReportResource} executionShareReportResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareExecutionReport(id, executionShareReportResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).shareExecutionReport(id, executionShareReportResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId
         * @param {number} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatedExecution(projectId, order, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).terminatedExecution(projectId, order, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionApiAxiosParamCreator(configuration).unlinkRelease(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ExecutionApi - factory interface
 * @export
 */
exports.ExecutionApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
         * @param {Array<number>} id
         * @param {number} projectId
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownload(id, projectId, fileType, options) {
            return exports.ExecutionApiFp(configuration).bulkDownload(id, projectId, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple Executions. Returns the deleted Execution details.
         * @param {number} projectId
         * @param {Array<number>} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(projectId, order, options) {
            return exports.ExecutionApiFp(configuration).delete1(projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Exports and downloads an Execution. Returns the Execution summary file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download1(id, fileType, options) {
            return exports.ExecutionApiFp(configuration).download1(id, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id, options) {
            return exports.ExecutionApiFp(configuration).downloadFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns an Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(id, options) {
            return exports.ExecutionApiFp(configuration).get1(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExecutions(id, pageable, options) {
            return exports.ExecutionApiFp(configuration).getLatestExecutions(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease(id, projectId, releaseId, options) {
            return exports.ExecutionApiFp(configuration).linkRelease(id, projectId, releaseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Pageable} pageable
         * @param {string} [batch]
         * @param {number} [projectId]
         * @param {number} [order]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(pageable, batch, projectId, order, options) {
            return exports.ExecutionApiFp(configuration).list(pageable, batch, projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Re-imports an Execution. Returns the newly imported Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reImportExecution(id, options) {
            return exports.ExecutionApiFp(configuration).reImportExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rerun an Execution.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rerunExecution(id, options) {
            return exports.ExecutionApiFp(configuration).rerunExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Allow users to send email with attached execution reports [PDF].
         * @param {number} id
         * @param {ExecutionShareReportResource} executionShareReportResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareExecutionReport(id, executionShareReportResource, options) {
            return exports.ExecutionApiFp(configuration).shareExecutionReport(id, executionShareReportResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Terminates a running Execution. Returns the terminated Execution detail.
         * @param {number} projectId
         * @param {number} order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatedExecution(projectId, order, options) {
            return exports.ExecutionApiFp(configuration).terminatedExecution(projectId, order, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease(id, options) {
            return exports.ExecutionApiFp(configuration).unlinkRelease(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExecutionApi - object-oriented interface
 * @export
 * @class ExecutionApi
 * @extends {BaseAPI}
 */
class ExecutionApi extends base_1.BaseAPI {
    /**
     *
     * @summary Exports and downloads multiple Executions. Returns the archive file comprising the Execution summaries.
     * @param {Array<number>} id
     * @param {number} projectId
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    bulkDownload(id, projectId, fileType, options) {
        return exports.ExecutionApiFp(this.configuration).bulkDownload(id, projectId, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple Executions. Returns the deleted Execution details.
     * @param {number} projectId
     * @param {Array<number>} order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    delete1(projectId, order, options) {
        return exports.ExecutionApiFp(this.configuration).delete1(projectId, order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Exports and downloads an Execution. Returns the Execution summary file.
     * @param {number} id
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    download1(id, fileType, options) {
        return exports.ExecutionApiFp(this.configuration).download1(id, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads all uploaded files of an Execution. Returns the archive file comprising all Execution\'s files.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    downloadFile(id, options) {
        return exports.ExecutionApiFp(this.configuration).downloadFile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns an Execution detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    get1(id, options) {
        return exports.ExecutionApiFp(this.configuration).get1(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    getLatestExecutions(id, pageable, options) {
        return exports.ExecutionApiFp(this.configuration).getLatestExecutions(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link an Execution to a Release. Returns the updated Execution detail.
     * @param {number} id
     * @param {number} projectId
     * @param {number} releaseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    linkRelease(id, projectId, releaseId, options) {
        return exports.ExecutionApiFp(this.configuration).linkRelease(id, projectId, releaseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Pageable} pageable
     * @param {string} [batch]
     * @param {number} [projectId]
     * @param {number} [order]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    list(pageable, batch, projectId, order, options) {
        return exports.ExecutionApiFp(this.configuration).list(pageable, batch, projectId, order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Re-imports an Execution. Returns the newly imported Execution detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    reImportExecution(id, options) {
        return exports.ExecutionApiFp(this.configuration).reImportExecution(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Rerun an Execution.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    rerunExecution(id, options) {
        return exports.ExecutionApiFp(this.configuration).rerunExecution(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Allow users to send email with attached execution reports [PDF].
     * @param {number} id
     * @param {ExecutionShareReportResource} executionShareReportResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    shareExecutionReport(id, executionShareReportResource, options) {
        return exports.ExecutionApiFp(this.configuration).shareExecutionReport(id, executionShareReportResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Terminates a running Execution. Returns the terminated Execution detail.
     * @param {number} projectId
     * @param {number} order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    terminatedExecution(projectId, order, options) {
        return exports.ExecutionApiFp(this.configuration).terminatedExecution(projectId, order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink an Execution to a Release. Returns the updated Execution detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionApi
     */
    unlinkRelease(id, options) {
        return exports.ExecutionApiFp(this.configuration).unlinkRelease(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExecutionApi = ExecutionApi;
/**
 * ExecutionRequestApi - axios parameter creator
 * @export
 */
exports.ExecutionRequestApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: (id, fileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling download.');
            }
            const localVarPath = `/api/v1/requests/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns an Execution Request detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRequest: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getExecutionRequest.');
            }
            const localVarPath = `/api/v1/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExecutionRequestApi - functional programming interface
 * @export
 */
exports.ExecutionRequestApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id, fileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionRequestApiAxiosParamCreator(configuration).download(id, fileType, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns an Execution Request detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRequest(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionRequestApiAxiosParamCreator(configuration).getExecutionRequest(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ExecutionRequestApi - factory interface
 * @export
 */
exports.ExecutionRequestApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Downloads an Execution Request report. Returns the report file.
         * @param {number} id
         * @param {string} [fileType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id, fileType, options) {
            return exports.ExecutionRequestApiFp(configuration).download(id, fileType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns an Execution Request detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRequest(id, options) {
            return exports.ExecutionRequestApiFp(configuration).getExecutionRequest(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExecutionRequestApi - object-oriented interface
 * @export
 * @class ExecutionRequestApi
 * @extends {BaseAPI}
 */
class ExecutionRequestApi extends base_1.BaseAPI {
    /**
     *
     * @summary Downloads an Execution Request report. Returns the report file.
     * @param {number} id
     * @param {string} [fileType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionRequestApi
     */
    download(id, fileType, options) {
        return exports.ExecutionRequestApiFp(this.configuration).download(id, fileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns an Execution Request detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionRequestApi
     */
    getExecutionRequest(id, options) {
        return exports.ExecutionRequestApiFp(this.configuration).getExecutionRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExecutionRequestApi = ExecutionRequestApi;
/**
 * ExecutionTestResultApi - axios parameter creator
 * @export
 */
exports.ExecutionTestResultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns an Execution Test Result detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get2.');
            }
            const localVarPath = `/api/v1/test-results/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStdout: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getStdout.');
            }
            const localVarPath = `/api/v1/test-results/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIncidents: (id, incidentExecutionTestResultResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling linkIncidents.');
            }
            // verify required parameter 'incidentExecutionTestResultResource' is not null or undefined
            if (incidentExecutionTestResultResource === null || incidentExecutionTestResultResource === undefined) {
                throw new base_1.RequiredError('incidentExecutionTestResultResource', 'Required parameter incidentExecutionTestResultResource was null or undefined when calling linkIncidents.');
            }
            const localVarPath = `/api/v1/test-results/{id}/incidents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof incidentExecutionTestResultResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(incidentExecutionTestResultResource !== undefined ? incidentExecutionTestResultResource : {})
                : (incidentExecutionTestResultResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRetested: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling markAsRetested.');
            }
            const localVarPath = `/api/v1/test-results/{id}/mask-as-retested`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIncidents: (id, incidentExecutionTestResultResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling unlinkIncidents.');
            }
            // verify required parameter 'incidentExecutionTestResultResource' is not null or undefined
            if (incidentExecutionTestResultResource === null || incidentExecutionTestResultResource === undefined) {
                throw new base_1.RequiredError('incidentExecutionTestResultResource', 'Required parameter incidentExecutionTestResultResource was null or undefined when calling unlinkIncidents.');
            }
            const localVarPath = `/api/v1/test-results/{id}/incidents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof incidentExecutionTestResultResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(incidentExecutionTestResultResource !== undefined ? incidentExecutionTestResultResource : {})
                : (incidentExecutionTestResultResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExecutionTestResultApi - functional programming interface
 * @export
 */
exports.ExecutionTestResultApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns an Execution Test Result detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestResultApiAxiosParamCreator(configuration).get2(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStdout(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestResultApiAxiosParamCreator(configuration).getStdout(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIncidents(id, incidentExecutionTestResultResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestResultApiAxiosParamCreator(configuration).linkIncidents(id, incidentExecutionTestResultResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRetested(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestResultApiAxiosParamCreator(configuration).markAsRetested(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIncidents(id, incidentExecutionTestResultResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestResultApiAxiosParamCreator(configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ExecutionTestResultApi - factory interface
 * @export
 */
exports.ExecutionTestResultApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns an Execution Test Result detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(id, options) {
            return exports.ExecutionTestResultApiFp(configuration).get2(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads a test result\'s log. Returns the log file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStdout(id, options) {
            return exports.ExecutionTestResultApiFp(configuration).getStdout(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkIncidents(id, incidentExecutionTestResultResource, options) {
            return exports.ExecutionTestResultApiFp(configuration).linkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRetested(id, options) {
            return exports.ExecutionTestResultApiFp(configuration).markAsRetested(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
         * @param {string} id
         * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkIncidents(id, incidentExecutionTestResultResource, options) {
            return exports.ExecutionTestResultApiFp(configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExecutionTestResultApi - object-oriented interface
 * @export
 * @class ExecutionTestResultApi
 * @extends {BaseAPI}
 */
class ExecutionTestResultApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns an Execution Test Result detail.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    get2(id, options) {
        return exports.ExecutionTestResultApiFp(this.configuration).get2(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads a test result\'s log. Returns the log file.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    getStdout(id, options) {
        return exports.ExecutionTestResultApiFp(this.configuration).getStdout(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link an Execution Test Result to a Task. Returns the created binding detail.
     * @param {string} id
     * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    linkIncidents(id, incidentExecutionTestResultResource, options) {
        return exports.ExecutionTestResultApiFp(this.configuration).linkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    markAsRetested(id, options) {
        return exports.ExecutionTestResultApiFp(this.configuration).markAsRetested(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink an Execution Test Result to a Task. Returns the deleted binding detail.
     * @param {string} id
     * @param {IncidentExecutionTestResultResource} incidentExecutionTestResultResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestResultApi
     */
    unlinkIncidents(id, incidentExecutionTestResultResource, options) {
        return exports.ExecutionTestResultApiFp(this.configuration).unlinkIncidents(id, incidentExecutionTestResultResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExecutionTestResultApi = ExecutionTestResultApi;
/**
 * ExecutionTestSuiteApi - axios parameter creator
 * @export
 */
exports.ExecutionTestSuiteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get3.');
            }
            const localVarPath = `/api/v1/execution-test-suites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExecutionTestSuiteApi - functional programming interface
 * @export
 */
exports.ExecutionTestSuiteApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ExecutionTestSuiteApiAxiosParamCreator(configuration).get3(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ExecutionTestSuiteApi - factory interface
 * @export
 */
exports.ExecutionTestSuiteApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns an Execution Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(id, options) {
            return exports.ExecutionTestSuiteApiFp(configuration).get3(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExecutionTestSuiteApi - object-oriented interface
 * @export
 * @class ExecutionTestSuiteApi
 * @extends {BaseAPI}
 */
class ExecutionTestSuiteApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns an Execution Test Suite detail.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExecutionTestSuiteApi
     */
    get3(id, options) {
        return exports.ExecutionTestSuiteApiFp(this.configuration).get3(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExecutionTestSuiteApi = ExecutionTestSuiteApi;
/**
 * FileApi - axios parameter creator
 * @export
 */
exports.FileApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Downloads a file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download2: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling download2.');
            }
            const localVarPath = `/api/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns an upload URL.
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl: (projectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getUploadUrl.');
            }
            const localVarPath = `/api/v1/files/upload-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns multiple upload URLs.
         * @param {number} projectId
         * @param {number} numberUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrls: (projectId, numberUrl, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getUploadUrls.');
            }
            // verify required parameter 'numberUrl' is not null or undefined
            if (numberUrl === null || numberUrl === undefined) {
                throw new base_1.RequiredError('numberUrl', 'Required parameter numberUrl was null or undefined when calling getUploadUrls.');
            }
            const localVarPath = `/api/v1/files/upload-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (numberUrl !== undefined) {
                localVarQueryParameter['numberUrl'] = numberUrl;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FileApi - functional programming interface
 * @export
 */
exports.FileApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Downloads a file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FileApiAxiosParamCreator(configuration).download2(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns an upload URL.
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(projectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FileApiAxiosParamCreator(configuration).getUploadUrl(projectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns multiple upload URLs.
         * @param {number} projectId
         * @param {number} numberUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrls(projectId, numberUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.FileApiAxiosParamCreator(configuration).getUploadUrls(projectId, numberUrl, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * FileApi - factory interface
 * @export
 */
exports.FileApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Downloads a file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download2(id, options) {
            return exports.FileApiFp(configuration).download2(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns an upload URL.
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(projectId, options) {
            return exports.FileApiFp(configuration).getUploadUrl(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns multiple upload URLs.
         * @param {number} projectId
         * @param {number} numberUrl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrls(projectId, numberUrl, options) {
            return exports.FileApiFp(configuration).getUploadUrls(projectId, numberUrl, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
class FileApi extends base_1.BaseAPI {
    /**
     *
     * @summary Downloads a file.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    download2(id, options) {
        return exports.FileApiFp(this.configuration).download2(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns an upload URL.
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getUploadUrl(projectId, options) {
        return exports.FileApiFp(this.configuration).getUploadUrl(projectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns multiple upload URLs.
     * @param {number} projectId
     * @param {number} numberUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    getUploadUrls(projectId, numberUrl, options) {
        return exports.FileApiFp(this.configuration).getUploadUrls(projectId, numberUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FileApi = FileApi;
/**
 * JobApi - axios parameter creator
 * @export
 */
exports.JobApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Cancels a Job.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling cancel.');
            }
            const localVarPath = `/api/v1/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Job detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get12: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get12.');
            }
            const localVarPath = `/api/v1/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: (uuid, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new base_1.RequiredError('uuid', 'Required parameter uuid was null or undefined when calling getJob.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new base_1.RequiredError('teamId', 'Required parameter teamId was null or undefined when calling getJob.');
            }
            const localVarPath = `/api/v1/jobs/get-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }
            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestJobs: (id, pageable, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getLatestJobs.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getLatestJobs.');
            }
            const localVarPath = `/api/v1/organizations/{id}/latest-jobs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Job\'s log.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getLog.');
            }
            const localVarPath = `/api/v1/jobs/{id}/get-log`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningJobs: (id, pageable, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getRunningJobs.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getRunningJobs.');
            }
            const localVarPath = `/api/v1/organizations/{id}/running-jobs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob: (jobResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'jobResource' is not null or undefined
            if (jobResource === null || jobResource === undefined) {
                throw new base_1.RequiredError('jobResource', 'Required parameter jobResource was null or undefined when calling updateJob.');
            }
            const localVarPath = `/api/v1/jobs/update-job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof jobResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jobResource !== undefined ? jobResource : {})
                : (jobResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * JobApi - functional programming interface
 * @export
 */
exports.JobApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Cancels a Job.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).cancel(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Job detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get12(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).get12(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(uuid, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).getJob(uuid, teamId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestJobs(id, pageable, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).getLatestJobs(id, pageable, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Job\'s log.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).getLog(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningJobs(id, pageable, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).getRunningJobs(id, pageable, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(jobResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.JobApiAxiosParamCreator(configuration).updateJob(jobResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * JobApi - factory interface
 * @export
 */
exports.JobApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Cancels a Job.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id, options) {
            return exports.JobApiFp(configuration).cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Job detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get12(id, options) {
            return exports.JobApiFp(configuration).get12(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the next queued Job of an Agent.
         * @param {string} uuid
         * @param {number} teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(uuid, teamId, options) {
            return exports.JobApiFp(configuration).getJob(uuid, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestJobs(id, pageable, options) {
            return exports.JobApiFp(configuration).getLatestJobs(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Job\'s log.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(id, options) {
            return exports.JobApiFp(configuration).getLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningJobs(id, pageable, options) {
            return exports.JobApiFp(configuration).getRunningJobs(id, pageable, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Job detail. Returns the updated Job detail.
         * @param {JobResource} jobResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob(jobResource, options) {
            return exports.JobApiFp(configuration).updateJob(jobResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
class JobApi extends base_1.BaseAPI {
    /**
     *
     * @summary Cancels a Job.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    cancel(id, options) {
        return exports.JobApiFp(this.configuration).cancel(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Job detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    get12(id, options) {
        return exports.JobApiFp(this.configuration).get12(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the next queued Job of an Agent.
     * @param {string} uuid
     * @param {number} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    getJob(uuid, teamId, options) {
        return exports.JobApiFp(this.configuration).getJob(uuid, teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    getLatestJobs(id, pageable, options) {
        return exports.JobApiFp(this.configuration).getLatestJobs(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Job\'s log.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    getLog(id, options) {
        return exports.JobApiFp(this.configuration).getLog(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    getRunningJobs(id, pageable, options) {
        return exports.JobApiFp(this.configuration).getRunningJobs(id, pageable, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Job detail. Returns the updated Job detail.
     * @param {JobResource} jobResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    updateJob(jobResource, options) {
        return exports.JobApiFp(this.configuration).updateJob(jobResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.JobApi = JobApi;
/**
 * KatalonRecorderApi - axios parameter creator
 * @export
 */
exports.KatalonRecorderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup: (uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling backup.');
            }
            const localVarPath = `/api/v1/katalon-recorder/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download3: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling download3.');
            }
            const localVarPath = `/api/v1/katalon-recorder/backup/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: (projectId, batch, isEnd, fileName, uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling upload.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling upload.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new base_1.RequiredError('isEnd', 'Required parameter isEnd was null or undefined when calling upload.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling upload.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling upload.');
            }
            const localVarPath = `/api/v1/katalon-recorder/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * KatalonRecorderApi - functional programming interface
 * @export
 */
exports.KatalonRecorderApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.KatalonRecorderApiAxiosParamCreator(configuration).backup(uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download3(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.KatalonRecorderApiAxiosParamCreator(configuration).download3(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(projectId, batch, isEnd, fileName, uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.KatalonRecorderApiAxiosParamCreator(configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * KatalonRecorderApi - factory interface
 * @export
 */
exports.KatalonRecorderApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Saves a Katalon Recorder backup detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(uploadedPath, options) {
            return exports.KatalonRecorderApiFp(configuration).backup(uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads a Katalon Recorder backup. Returns the backup file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download3(id, options) {
            return exports.KatalonRecorderApiFp(configuration).download3(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Uploads and processes a Katalon Recorder report.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(projectId, batch, isEnd, fileName, uploadedPath, options) {
            return exports.KatalonRecorderApiFp(configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * KatalonRecorderApi - object-oriented interface
 * @export
 * @class KatalonRecorderApi
 * @extends {BaseAPI}
 */
class KatalonRecorderApi extends base_1.BaseAPI {
    /**
     *
     * @summary Saves a Katalon Recorder backup detail.
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    backup(uploadedPath, options) {
        return exports.KatalonRecorderApiFp(this.configuration).backup(uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads a Katalon Recorder backup. Returns the backup file.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    download3(id, options) {
        return exports.KatalonRecorderApiFp(this.configuration).download3(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Uploads and processes a Katalon Recorder report.
     * @param {string} projectId
     * @param {string} batch
     * @param {string} isEnd
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KatalonRecorderApi
     */
    upload(projectId, batch, isEnd, fileName, uploadedPath, options) {
        return exports.KatalonRecorderApiFp(this.configuration).upload(projectId, batch, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.KatalonRecorderApi = KatalonRecorderApi;
/**
 * OrganizationTrialRequestResourceControllerApi - axios parameter creator
 * @export
 */
exports.OrganizationTrialRequestResourceControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get organization trial request data
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialRequest: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getTrialRequest.');
            }
            const localVarPath = `/api/v1/organizations/{id}/trial-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Submit organization trial request
         * @param {number} id
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTrialRequest: (id, organizationTrialRequestResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling submitTrialRequest.');
            }
            // verify required parameter 'organizationTrialRequestResource' is not null or undefined
            if (organizationTrialRequestResource === null || organizationTrialRequestResource === undefined) {
                throw new base_1.RequiredError('organizationTrialRequestResource', 'Required parameter organizationTrialRequestResource was null or undefined when calling submitTrialRequest.');
            }
            const localVarPath = `/api/v1/organizations/{id}/trial-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof organizationTrialRequestResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(organizationTrialRequestResource !== undefined ? organizationTrialRequestResource : {})
                : (organizationTrialRequestResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrganizationTrialRequestResourceControllerApi - functional programming interface
 * @export
 */
exports.OrganizationTrialRequestResourceControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get organization trial request data
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialRequest(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrganizationTrialRequestResourceControllerApiAxiosParamCreator(configuration).getTrialRequest(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Submit organization trial request
         * @param {number} id
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTrialRequest(id, organizationTrialRequestResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrganizationTrialRequestResourceControllerApiAxiosParamCreator(configuration).submitTrialRequest(id, organizationTrialRequestResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * OrganizationTrialRequestResourceControllerApi - factory interface
 * @export
 */
exports.OrganizationTrialRequestResourceControllerApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Get organization trial request data
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrialRequest(id, options) {
            return exports.OrganizationTrialRequestResourceControllerApiFp(configuration).getTrialRequest(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Submit organization trial request
         * @param {number} id
         * @param {OrganizationTrialRequestResource} organizationTrialRequestResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTrialRequest(id, organizationTrialRequestResource, options) {
            return exports.OrganizationTrialRequestResourceControllerApiFp(configuration).submitTrialRequest(id, organizationTrialRequestResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationTrialRequestResourceControllerApi - object-oriented interface
 * @export
 * @class OrganizationTrialRequestResourceControllerApi
 * @extends {BaseAPI}
 */
class OrganizationTrialRequestResourceControllerApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get organization trial request data
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationTrialRequestResourceControllerApi
     */
    getTrialRequest(id, options) {
        return exports.OrganizationTrialRequestResourceControllerApiFp(this.configuration).getTrialRequest(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Submit organization trial request
     * @param {number} id
     * @param {OrganizationTrialRequestResource} organizationTrialRequestResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationTrialRequestResourceControllerApi
     */
    submitTrialRequest(id, organizationTrialRequestResource, options) {
        return exports.OrganizationTrialRequestResourceControllerApiFp(this.configuration).submitTrialRequest(id, organizationTrialRequestResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationTrialRequestResourceControllerApi = OrganizationTrialRequestResourceControllerApi;
/**
 * ProjectApi - axios parameter creator
 * @export
 */
exports.ProjectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: (projectResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new base_1.RequiredError('projectResource', 'Required parameter projectResource was null or undefined when calling create2.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {ProjectSettingResource} projectSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate: (projectSettingResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectSettingResource' is not null or undefined
            if (projectSettingResource === null || projectSettingResource === undefined) {
                throw new base_1.RequiredError('projectSettingResource', 'Required parameter projectSettingResource was null or undefined when calling createOrUpdate.');
            }
            const localVarPath = `/api/v1/project-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof projectSettingResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(projectSettingResource !== undefined ? projectSettingResource : {})
                : (projectSettingResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create sample data for project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleData: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling createSampleData.');
            }
            const localVarPath = `/api/v1/projects/{id}/sample-data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete2.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get5: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get5.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get6: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get6.');
            }
            const localVarPath = `/api/v1/project-settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable
         * @param {number} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: (pageable, teamId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling list1.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: (projectResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new base_1.RequiredError('projectResource', 'Required parameter projectResource was null or undefined when calling update2.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: (projectResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectResource' is not null or undefined
            if (projectResource === null || projectResource === undefined) {
                throw new base_1.RequiredError('projectResource', 'Required parameter projectResource was null or undefined when calling updateStatus.');
            }
            const localVarPath = `/api/v1/projects/update-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof projectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(projectResource !== undefined ? projectResource : {})
                : (projectResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProjectApi - functional programming interface
 * @export
 */
exports.ProjectApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(projectResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).create2(projectResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {ProjectSettingResource} projectSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate(projectSettingResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).createOrUpdate(projectSettingResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create sample data for project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleData(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).createSampleData(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).delete2(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get5(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).get5(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get6(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).get6(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable
         * @param {number} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(pageable, teamId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).list1(pageable, teamId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(projectResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).update2(projectResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(projectResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectApiAxiosParamCreator(configuration).updateStatus(projectResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProjectApi - factory interface
 * @export
 */
exports.ProjectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates a new Project. Returns the created Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(projectResource, options) {
            return exports.ProjectApiFp(configuration).create2(projectResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ProjectSettingResource} projectSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate(projectSettingResource, options) {
            return exports.ProjectApiFp(configuration).createOrUpdate(projectSettingResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create sample data for project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleData(id, options) {
            return exports.ProjectApiFp(configuration).createSampleData(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a Project. Returns the deleted Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id, options) {
            return exports.ProjectApiFp(configuration).delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get5(id, options) {
            return exports.ProjectApiFp(configuration).get5(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get6(id, options) {
            return exports.ProjectApiFp(configuration).get6(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all Projects of a Team.
         * @param {Pageable} pageable
         * @param {number} [teamId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(pageable, teamId, options) {
            return exports.ProjectApiFp(configuration).list1(pageable, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Project detail. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(projectResource, options) {
            return exports.ProjectApiFp(configuration).update2(projectResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Project status. Returns the updated Project detail.
         * @param {ProjectResource} projectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(projectResource, options) {
            return exports.ProjectApiFp(configuration).updateStatus(projectResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
class ProjectApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new Project. Returns the created Project detail.
     * @param {ProjectResource} projectResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    create2(projectResource, options) {
        return exports.ProjectApiFp(this.configuration).create2(projectResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ProjectSettingResource} projectSettingResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    createOrUpdate(projectSettingResource, options) {
        return exports.ProjectApiFp(this.configuration).createOrUpdate(projectSettingResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create sample data for project.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    createSampleData(id, options) {
        return exports.ProjectApiFp(this.configuration).createSampleData(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a Project. Returns the deleted Project detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    delete2(id, options) {
        return exports.ProjectApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Project detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    get5(id, options) {
        return exports.ProjectApiFp(this.configuration).get5(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    get6(id, options) {
        return exports.ProjectApiFp(this.configuration).get6(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all Projects of a Team.
     * @param {Pageable} pageable
     * @param {number} [teamId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    list1(pageable, teamId, options) {
        return exports.ProjectApiFp(this.configuration).list1(pageable, teamId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Project detail. Returns the updated Project detail.
     * @param {ProjectResource} projectResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    update2(projectResource, options) {
        return exports.ProjectApiFp(this.configuration).update2(projectResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Project status. Returns the updated Project detail.
     * @param {ProjectResource} projectResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    updateStatus(projectResource, options) {
        return exports.ProjectApiFp(this.configuration).updateStatus(projectResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProjectApi = ProjectApi;
/**
 * ProjectConfigurationResourceControllerApi - axios parameter creator
 * @export
 */
exports.ProjectConfigurationResourceControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} id
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get14: (id, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get14.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling get14.');
            }
            const localVarPath = `/api/v1/project-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/time-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id
         * @param {ProjectConfigurationResource} projectConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8: (id, projectConfigurationResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling update8.');
            }
            // verify required parameter 'projectConfigurationResource' is not null or undefined
            if (projectConfigurationResource === null || projectConfigurationResource === undefined) {
                throw new base_1.RequiredError('projectConfigurationResource', 'Required parameter projectConfigurationResource was null or undefined when calling update8.');
            }
            const localVarPath = `/api/v1/project-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof projectConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(projectConfigurationResource !== undefined ? projectConfigurationResource : {})
                : (projectConfigurationResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProjectConfigurationResourceControllerApi - functional programming interface
 * @export
 */
exports.ProjectConfigurationResourceControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @param {number} id
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get14(id, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).get14(id, name, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).listTimeZones(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id
         * @param {ProjectConfigurationResource} projectConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8(id, projectConfigurationResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProjectConfigurationResourceControllerApiAxiosParamCreator(configuration).update8(id, projectConfigurationResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProjectConfigurationResourceControllerApi - factory interface
 * @export
 */
exports.ProjectConfigurationResourceControllerApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {number} id
         * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get14(id, name, options) {
            return exports.ProjectConfigurationResourceControllerApiFp(configuration).get14(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimeZones(options) {
            return exports.ProjectConfigurationResourceControllerApiFp(configuration).listTimeZones(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id
         * @param {ProjectConfigurationResource} projectConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update8(id, projectConfigurationResource, options) {
            return exports.ProjectConfigurationResourceControllerApiFp(configuration).update8(id, projectConfigurationResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProjectConfigurationResourceControllerApi - object-oriented interface
 * @export
 * @class ProjectConfigurationResourceControllerApi
 * @extends {BaseAPI}
 */
class ProjectConfigurationResourceControllerApi extends base_1.BaseAPI {
    /**
     *
     * @param {number} id
     * @param {'TIMEZONE' | 'ASSERTION_PATTERN'} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    get14(id, name, options) {
        return exports.ProjectConfigurationResourceControllerApiFp(this.configuration).get14(id, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    listTimeZones(options) {
        return exports.ProjectConfigurationResourceControllerApiFp(this.configuration).listTimeZones(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id
     * @param {ProjectConfigurationResource} projectConfigurationResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectConfigurationResourceControllerApi
     */
    update8(id, projectConfigurationResource, options) {
        return exports.ProjectConfigurationResourceControllerApiFp(this.configuration).update8(id, projectConfigurationResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProjectConfigurationResourceControllerApi = ProjectConfigurationResourceControllerApi;
/**
 * ReleaseApi - axios parameter creator
 * @export
 */
exports.ReleaseApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id
         * @param {boolean} closed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeRelease: (id, closed, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling activeRelease.');
            }
            // verify required parameter 'closed' is not null or undefined
            if (closed === null || closed === undefined) {
                throw new base_1.RequiredError('closed', 'Required parameter closed was null or undefined when calling activeRelease.');
            }
            const localVarPath = `/api/v1/releases/{id}/active`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (closed !== undefined) {
                localVarQueryParameter['closed'] = closed;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate1: (releaseResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'releaseResource' is not null or undefined
            if (releaseResource === null || releaseResource === undefined) {
                throw new base_1.RequiredError('releaseResource', 'Required parameter releaseResource was null or undefined when calling createOrUpdate1.');
            }
            const localVarPath = `/api/v1/releases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof releaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(releaseResource !== undefined ? releaseResource : {})
                : (releaseResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete3.');
            }
            const localVarPath = `/api/v1/releases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: (releaseResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'releaseResource' is not null or undefined
            if (releaseResource === null || releaseResource === undefined) {
                throw new base_1.RequiredError('releaseResource', 'Required parameter releaseResource was null or undefined when calling update3.');
            }
            const localVarPath = `/api/v1/releases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof releaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(releaseResource !== undefined ? releaseResource : {})
                : (releaseResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ReleaseApi - functional programming interface
 * @export
 */
exports.ReleaseApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id
         * @param {boolean} closed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeRelease(id, closed, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReleaseApiAxiosParamCreator(configuration).activeRelease(id, closed, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate1(releaseResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReleaseApiAxiosParamCreator(configuration).createOrUpdate1(releaseResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReleaseApiAxiosParamCreator(configuration).delete3(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(releaseResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReleaseApiAxiosParamCreator(configuration).update3(releaseResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ReleaseApi - factory interface
 * @export
 */
exports.ReleaseApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Open or close a Release. Returns the updated Release detail.
         * @param {number} id
         * @param {boolean} closed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeRelease(id, closed, options) {
            return exports.ReleaseApiFp(configuration).activeRelease(id, closed, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates or updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate1(releaseResource, options) {
            return exports.ReleaseApiFp(configuration).createOrUpdate1(releaseResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a Release. Returns the Release details.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id, options) {
            return exports.ReleaseApiFp(configuration).delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Release. Returns the Release details.
         * @param {ReleaseResource} releaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(releaseResource, options) {
            return exports.ReleaseApiFp(configuration).update3(releaseResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ReleaseApi - object-oriented interface
 * @export
 * @class ReleaseApi
 * @extends {BaseAPI}
 */
class ReleaseApi extends base_1.BaseAPI {
    /**
     *
     * @summary Open or close a Release. Returns the updated Release detail.
     * @param {number} id
     * @param {boolean} closed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    activeRelease(id, closed, options) {
        return exports.ReleaseApiFp(this.configuration).activeRelease(id, closed, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates or updates a Release. Returns the Release details.
     * @param {ReleaseResource} releaseResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    createOrUpdate1(releaseResource, options) {
        return exports.ReleaseApiFp(this.configuration).createOrUpdate1(releaseResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a Release. Returns the Release details.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    delete3(id, options) {
        return exports.ReleaseApiFp(this.configuration).delete3(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Release. Returns the Release details.
     * @param {ReleaseResource} releaseResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseApi
     */
    update3(releaseResource, options) {
        return exports.ReleaseApiFp(this.configuration).update3(releaseResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ReleaseApi = ReleaseApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */
exports.SearchApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: (q, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new base_1.RequiredError('q', 'Required parameter q was null or undefined when calling search.');
            }
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1: (searchRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'searchRequest' is not null or undefined
            if (searchRequest === null || searchRequest === undefined) {
                throw new base_1.RequiredError('searchRequest', 'Required parameter searchRequest was null or undefined when calling search1.');
            }
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof searchRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : (searchRequest || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/search/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SearchApi - functional programming interface
 * @export
 */
exports.SearchApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).search(q, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).search1(searchRequest, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).test(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SearchApi - factory interface
 * @export
 */
exports.SearchApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {string} q
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q, options) {
            return exports.SearchApiFp(configuration).search(q, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchRequest, options) {
            return exports.SearchApiFp(configuration).search1(searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the search configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options) {
            return exports.SearchApiFp(configuration).test(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
class SearchApi extends base_1.BaseAPI {
    /**
     *
     * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
     * @param {string} q
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    search(q, options) {
        return exports.SearchApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Queries the resources of a specific type by multiple conditions. Returns the pageable resources satisfying the query.
     * @param {SearchRequest} searchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    search1(searchRequest, options) {
        return exports.SearchApiFp(this.configuration).search1(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the search configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    test(options) {
        return exports.SearchApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SearchApi = SearchApi;
/**
 * TaskApi - axios parameter creator
 * @export
 */
exports.TaskApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident: (incidentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'incidentResource' is not null or undefined
            if (incidentResource === null || incidentResource === undefined) {
                throw new base_1.RequiredError('incidentResource', 'Required parameter incidentResource was null or undefined when calling createIncident.');
            }
            const localVarPath = `/api/v1/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof incidentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(incidentResource !== undefined ? incidentResource : {})
                : (incidentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Task detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get4.');
            }
            const localVarPath = `/api/v1/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: (incidentResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'incidentResource' is not null or undefined
            if (incidentResource === null || incidentResource === undefined) {
                throw new base_1.RequiredError('incidentResource', 'Required parameter incidentResource was null or undefined when calling update1.');
            }
            const localVarPath = `/api/v1/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof incidentResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(incidentResource !== undefined ? incidentResource : {})
                : (incidentResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TaskApi - functional programming interface
 * @export
 */
exports.TaskApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident(incidentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaskApiAxiosParamCreator(configuration).createIncident(incidentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Task detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaskApiAxiosParamCreator(configuration).get4(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(incidentResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaskApiAxiosParamCreator(configuration).update1(incidentResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TaskApi - factory interface
 * @export
 */
exports.TaskApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates a Task for the test results. Returns the created Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident(incidentResource, options) {
            return exports.TaskApiFp(configuration).createIncident(incidentResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Task detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(id, options) {
            return exports.TaskApiFp(configuration).get4(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Task detail. Returns the updated Task detail.
         * @param {IncidentResource} incidentResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(incidentResource, options) {
            return exports.TaskApiFp(configuration).update1(incidentResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
class TaskApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a Task for the test results. Returns the created Task detail.
     * @param {IncidentResource} incidentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    createIncident(incidentResource, options) {
        return exports.TaskApiFp(this.configuration).createIncident(incidentResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Task detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    get4(id, options) {
        return exports.TaskApiFp(this.configuration).get4(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Task detail. Returns the updated Task detail.
     * @param {IncidentResource} incidentResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    update1(incidentResource, options) {
        return exports.TaskApiFp(this.configuration).update1(incidentResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskApi = TaskApi;
/**
 * TeamApi - axios parameter creator
 * @export
 */
exports.TeamApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: (teamResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'teamResource' is not null or undefined
            if (teamResource === null || teamResource === undefined) {
                throw new base_1.RequiredError('teamResource', 'Required parameter teamResource was null or undefined when calling create3.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof teamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(teamResource !== undefined ? teamResource : {})
                : (teamResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete4.');
            }
            const localVarPath = `/api/v1/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get7: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get7.');
            }
            const localVarPath = `/api/v1/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2: (pageable, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new base_1.RequiredError('pageable', 'Required parameter pageable was null or undefined when calling list2.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4: (teamResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'teamResource' is not null or undefined
            if (teamResource === null || teamResource === undefined) {
                throw new base_1.RequiredError('teamResource', 'Required parameter teamResource was null or undefined when calling update4.');
            }
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof teamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(teamResource !== undefined ? teamResource : {})
                : (teamResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTeam: (userTeamResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userTeamResource' is not null or undefined
            if (userTeamResource === null || userTeamResource === undefined) {
                throw new base_1.RequiredError('userTeamResource', 'Required parameter userTeamResource was null or undefined when calling updateUserTeam.');
            }
            const localVarPath = `/api/v1/permission/team/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof userTeamResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(userTeamResource !== undefined ? userTeamResource : {})
                : (userTeamResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TeamApi - functional programming interface
 * @export
 */
exports.TeamApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(teamResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).create3(teamResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).delete4(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get7(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).get7(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2(pageable, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).list2(pageable, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(teamResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).update4(teamResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTeam(userTeamResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TeamApiAxiosParamCreator(configuration).updateUserTeam(userTeamResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TeamApi - factory interface
 * @export
 */
exports.TeamApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates a new Team. Returns the created Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(teamResource, options) {
            return exports.TeamApiFp(configuration).create3(teamResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Team. Returns the delete Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id, options) {
            return exports.TeamApiFp(configuration).delete4(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Team detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get7(id, options) {
            return exports.TeamApiFp(configuration).get7(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns all Teams of the current User.
         * @param {Pageable} pageable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2(pageable, options) {
            return exports.TeamApiFp(configuration).list2(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Team detail. Returns the updated Team detail.
         * @param {TeamResource} teamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update4(teamResource, options) {
            return exports.TeamApiFp(configuration).update4(teamResource, options).then((request) => request(axios, basePath));
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Updates the role of a User in a Team. Returns the updated detail.
         * @param {UserTeamResource} userTeamResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTeam(userTeamResource, options) {
            return exports.TeamApiFp(configuration).updateUserTeam(userTeamResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
class TeamApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new Team. Returns the created Team detail.
     * @param {TeamResource} teamResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    create3(teamResource, options) {
        return exports.TeamApiFp(this.configuration).create3(teamResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Team. Returns the delete Team detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    delete4(id, options) {
        return exports.TeamApiFp(this.configuration).delete4(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Team detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    get7(id, options) {
        return exports.TeamApiFp(this.configuration).get7(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns all Teams of the current User.
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    list2(pageable, options) {
        return exports.TeamApiFp(this.configuration).list2(pageable, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Team detail. Returns the updated Team detail.
     * @param {TeamResource} teamResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    update4(teamResource, options) {
        return exports.TeamApiFp(this.configuration).update4(teamResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Updates the role of a User in a Team. Returns the updated detail.
     * @param {UserTeamResource} userTeamResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    updateUserTeam(userTeamResource, options) {
        return exports.TeamApiFp(this.configuration).updateUserTeam(userTeamResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TeamApi = TeamApi;
/**
 * TestCaseApi - axios parameter creator
 * @export
 */
exports.TestCaseApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Case detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get8: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get8.');
            }
            const localVarPath = `/api/v1/test-cases/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5: (testCaseResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'testCaseResource' is not null or undefined
            if (testCaseResource === null || testCaseResource === undefined) {
                throw new base_1.RequiredError('testCaseResource', 'Required parameter testCaseResource was null or undefined when calling update5.');
            }
            const localVarPath = `/api/v1/test-cases/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof testCaseResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testCaseResource !== undefined ? testCaseResource : {})
                : (testCaseResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestCaseApi - functional programming interface
 * @export
 */
exports.TestCaseApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Case detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get8(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestCaseApiAxiosParamCreator(configuration).get8(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(testCaseResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestCaseApiAxiosParamCreator(configuration).update5(testCaseResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestCaseApi - factory interface
 * @export
 */
exports.TestCaseApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns a Test Case detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get8(id, options) {
            return exports.TestCaseApiFp(configuration).get8(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a Test Case.
         * @param {TestCaseResource} testCaseResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update5(testCaseResource, options) {
            return exports.TestCaseApiFp(configuration).update5(testCaseResource, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestCaseApi - object-oriented interface
 * @export
 * @class TestCaseApi
 * @extends {BaseAPI}
 */
class TestCaseApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns a Test Case detail.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestCaseApi
     */
    get8(id, options) {
        return exports.TestCaseApiFp(this.configuration).get8(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a Test Case.
     * @param {TestCaseResource} testCaseResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestCaseApi
     */
    update5(testCaseResource, options) {
        return exports.TestCaseApiFp(this.configuration).update5(testCaseResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestCaseApi = TestCaseApi;
/**
 * TestObjectApi - axios parameter creator
 * @export
 */
exports.TestObjectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Object detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get15: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get15.');
            }
            const localVarPath = `/api/v1/test-object-entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestObjectApi - functional programming interface
 * @export
 */
exports.TestObjectApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Object detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get15(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestObjectApiAxiosParamCreator(configuration).get15(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestObjectApi - factory interface
 * @export
 */
exports.TestObjectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns a Test Object detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get15(id, options) {
            return exports.TestObjectApiFp(configuration).get15(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestObjectApi - object-oriented interface
 * @export
 * @class TestObjectApi
 * @extends {BaseAPI}
 */
class TestObjectApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns a Test Object detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestObjectApi
     */
    get15(id, options) {
        return exports.TestObjectApiFp(this.configuration).get15(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestObjectApi = TestObjectApi;
/**
 * TestPlanApi - axios parameter creator
 * @export
 */
exports.TestPlanApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndTriggerSample: (runConfigurationResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'runConfigurationResource' is not null or undefined
            if (runConfigurationResource === null || runConfigurationResource === undefined) {
                throw new base_1.RequiredError('runConfigurationResource', 'Required parameter runConfigurationResource was null or undefined when calling createAndTriggerSample.');
            }
            const localVarPath = `/api/v1/run-configurations/sample`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof runConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(runConfigurationResource !== undefined ? runConfigurationResource : {})
                : (runConfigurationResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {boolean} [verifyRunConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateConfiguration: (runConfigurationResource, verifyRunConfiguration, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'runConfigurationResource' is not null or undefined
            if (runConfigurationResource === null || runConfigurationResource === undefined) {
                throw new base_1.RequiredError('runConfigurationResource', 'Required parameter runConfigurationResource was null or undefined when calling createOrUpdateConfiguration.');
            }
            const localVarPath = `/api/v1/run-configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (verifyRunConfiguration !== undefined) {
                localVarQueryParameter['verifyRunConfiguration'] = verifyRunConfiguration;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof runConfigurationResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(runConfigurationResource !== undefined ? runConfigurationResource : {})
                : (runConfigurationResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete5.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease1: (id, projectId, releaseId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling linkRelease1.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling linkRelease1.');
            }
            // verify required parameter 'releaseId' is not null or undefined
            if (releaseId === null || releaseId === undefined) {
                throw new base_1.RequiredError('releaseId', 'Required parameter releaseId was null or undefined when calling linkRelease1.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/link-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (releaseId !== undefined) {
                localVarQueryParameter['releaseId'] = releaseId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease1: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling unlinkRelease1.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/unlink-release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestPlanApi - functional programming interface
 * @export
 */
exports.TestPlanApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndTriggerSample(runConfigurationResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestPlanApiAxiosParamCreator(configuration).createAndTriggerSample(runConfigurationResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {boolean} [verifyRunConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestPlanApiAxiosParamCreator(configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestPlanApiAxiosParamCreator(configuration).delete5(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease1(id, projectId, releaseId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestPlanApiAxiosParamCreator(configuration).linkRelease1(id, projectId, releaseId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease1(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestPlanApiAxiosParamCreator(configuration).unlinkRelease1(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestPlanApi - factory interface
 * @export
 */
exports.TestPlanApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndTriggerSample(runConfigurationResource, options) {
            return exports.TestPlanApiFp(configuration).createAndTriggerSample(runConfigurationResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
         * @param {RunConfigurationResource} runConfigurationResource
         * @param {boolean} [verifyRunConfiguration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options) {
            return exports.TestPlanApiFp(configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete5(id, options) {
            return exports.TestPlanApiFp(configuration).delete5(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {number} projectId
         * @param {number} releaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkRelease1(id, projectId, releaseId, options) {
            return exports.TestPlanApiFp(configuration).linkRelease1(id, projectId, releaseId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkRelease1(id, options) {
            return exports.TestPlanApiFp(configuration).unlinkRelease1(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestPlanApi - object-oriented interface
 * @export
 * @class TestPlanApi
 * @extends {BaseAPI}
 */
class TestPlanApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates and triggers a sample Test Plan. Returns the created Test Plan detail.
     * @param {RunConfigurationResource} runConfigurationResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    createAndTriggerSample(runConfigurationResource, options) {
        return exports.TestPlanApiFp(this.configuration).createAndTriggerSample(runConfigurationResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates or updates a Test Plan. Returns the Test Plan detail.
     * @param {RunConfigurationResource} runConfigurationResource
     * @param {boolean} [verifyRunConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options) {
        return exports.TestPlanApiFp(this.configuration).createOrUpdateConfiguration(runConfigurationResource, verifyRunConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a Test Plan. Returns the deleted Test Plan detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    delete5(id, options) {
        return exports.TestPlanApiFp(this.configuration).delete5(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Link an Run Configuration to a Release. Returns the updated Run Configuration detail.
     * @param {number} id
     * @param {number} projectId
     * @param {number} releaseId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    linkRelease1(id, projectId, releaseId, options) {
        return exports.TestPlanApiFp(this.configuration).linkRelease1(id, projectId, releaseId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Unlink an Run Configuration to a Release. Returns the updated Run Configuration detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestPlanApi
     */
    unlinkRelease1(id, options) {
        return exports.TestPlanApiFp(this.configuration).unlinkRelease1(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestPlanApi = TestPlanApi;
/**
 * TestProjectApi - axios parameter creator
 * @export
 */
exports.TestProjectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6: (id, schedulerResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling create6.');
            }
            // verify required parameter 'schedulerResource' is not null or undefined
            if (schedulerResource === null || schedulerResource === undefined) {
                throw new base_1.RequiredError('schedulerResource', 'Required parameter schedulerResource was null or undefined when calling create6.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof schedulerResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(schedulerResource !== undefined ? schedulerResource : {})
                : (schedulerResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitRepo: (gitRepositoryResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'gitRepositoryResource' is not null or undefined
            if (gitRepositoryResource === null || gitRepositoryResource === undefined) {
                throw new base_1.RequiredError('gitRepositoryResource', 'Required parameter gitRepositoryResource was null or undefined when calling createGitRepo.');
            }
            const localVarPath = `/api/v1/git/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof gitRepositoryResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(gitRepositoryResource !== undefined ? gitRepositoryResource : {})
                : (gitRepositoryResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {'KS' | 'GIT'} type
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSample: (name, type, projectId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling createSample.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new base_1.RequiredError('type', 'Required parameter type was null or undefined when calling createSample.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling createSample.');
            }
            const localVarPath = `/api/v1/test-projects/sample`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete6.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7: (id, schedulerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling delete7.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new base_1.RequiredError('schedulerId', 'Required parameter schedulerId was null or undefined when calling delete7.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download4: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling download4.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Test Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get17: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get17.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduler: (id, schedulerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getScheduler.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new base_1.RequiredError('schedulerId', 'Required parameter schedulerId was null or undefined when calling getScheduler.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestProjectGit: (testProjectGitId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'testProjectGitId' is not null or undefined
            if (testProjectGitId === null || testProjectGitId === undefined) {
                throw new base_1.RequiredError('testProjectGitId', 'Required parameter testProjectGitId was null or undefined when calling getTestProjectGit.');
            }
            const localVarPath = `/api/v1/git/{testProjectGitId}`
                .replace(`{${"testProjectGitId"}}`, encodeURIComponent(String(testProjectGitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTSC: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling refreshTSC.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/refresh-tsc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        run: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling run.');
            }
            const localVarPath = `/api/v1/run-configurations/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id
         * @param {TestProjectResource} testProjectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10: (id, testProjectResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling update10.');
            }
            // verify required parameter 'testProjectResource' is not null or undefined
            if (testProjectResource === null || testProjectResource === undefined) {
                throw new base_1.RequiredError('testProjectResource', 'Required parameter testProjectResource was null or undefined when calling update10.');
            }
            const localVarPath = `/api/v1/test-projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof testProjectResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testProjectResource !== undefined ? testProjectResource : {})
                : (testProjectResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9: (id, schedulerId, schedulerResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling update9.');
            }
            // verify required parameter 'schedulerId' is not null or undefined
            if (schedulerId === null || schedulerId === undefined) {
                throw new base_1.RequiredError('schedulerId', 'Required parameter schedulerId was null or undefined when calling update9.');
            }
            // verify required parameter 'schedulerResource' is not null or undefined
            if (schedulerResource === null || schedulerResource === undefined) {
                throw new base_1.RequiredError('schedulerResource', 'Required parameter schedulerResource was null or undefined when calling update9.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/schedulers/{schedulerId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"schedulerId"}}`, encodeURIComponent(String(schedulerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof schedulerResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(schedulerResource !== undefined ? schedulerResource : {})
                : (schedulerResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitRepo: (gitRepositoryResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'gitRepositoryResource' is not null or undefined
            if (gitRepositoryResource === null || gitRepositoryResource === undefined) {
                throw new base_1.RequiredError('gitRepositoryResource', 'Required parameter gitRepositoryResource was null or undefined when calling updateGitRepo.');
            }
            const localVarPath = `/api/v1/git/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof gitRepositoryResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(gitRepositoryResource !== undefined ? gitRepositoryResource : {})
                : (gitRepositoryResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage: (id, batch, folderPath, fileName, uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new base_1.RequiredError('folderPath', 'Required parameter folderPath was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling updatePackage.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling updatePackage.');
            }
            const localVarPath = `/api/v1/test-projects/{id}/update-package`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [description]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1: (name, projectId, batch, folderPath, fileName, uploadedPath, description, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling upload1.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling upload1.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling upload1.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new base_1.RequiredError('folderPath', 'Required parameter folderPath was null or undefined when calling upload1.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling upload1.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling upload1.');
            }
            const localVarPath = `/api/v1/test-projects/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestProjectApi - functional programming interface
 * @export
 */
exports.TestProjectApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6(id, schedulerResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).create6(id, schedulerResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitRepo(gitRepositoryResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).createGitRepo(gitRepositoryResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {'KS' | 'GIT'} type
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSample(name, type, projectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).createSample(name, type, projectId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).delete6(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(id, schedulerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).delete7(id, schedulerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download4(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).download4(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Test Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get17(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).get17(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduler(id, schedulerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).getScheduler(id, schedulerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestProjectGit(testProjectGitId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).getTestProjectGit(testProjectGitId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTSC(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).refreshTSC(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        run(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).run(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id
         * @param {TestProjectResource} testProjectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10(id, testProjectResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).update10(id, testProjectResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9(id, schedulerId, schedulerResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).update9(id, schedulerId, schedulerResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitRepo(gitRepositoryResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).updateGitRepo(gitRepositoryResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage(id, batch, folderPath, fileName, uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [description]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestProjectApiAxiosParamCreator(configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestProjectApi - factory interface
 * @export
 */
exports.TestProjectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
         * @param {number} id
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create6(id, schedulerResource, options) {
            return exports.TestProjectApiFp(configuration).create6(id, schedulerResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a Git Test Project. Returns the Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitRepo(gitRepositoryResource, options) {
            return exports.TestProjectApiFp(configuration).createGitRepo(gitRepositoryResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new sample Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {'KS' | 'GIT'} type
         * @param {number} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSample(name, type, projectId, options) {
            return exports.TestProjectApiFp(configuration).createSample(name, type, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a Test Project. Returns the deleted Test Project.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete6(id, options) {
            return exports.TestProjectApiFp(configuration).delete6(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule. Returns the deleted schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete7(id, schedulerId, options) {
            return exports.TestProjectApiFp(configuration).delete7(id, schedulerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads a Test Project package. Returns the latest Test Project package file.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download4(id, options) {
            return exports.TestProjectApiFp(configuration).download4(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Test Project detail.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get17(id, options) {
            return exports.TestProjectApiFp(configuration).get17(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduler(id, schedulerId, options) {
            return exports.TestProjectApiFp(configuration).getScheduler(id, schedulerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a Git Test Project detail.
         * @param {number} testProjectGitId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestProjectGit(testProjectGitId, options) {
            return exports.TestProjectApiFp(configuration).getTestProjectGit(testProjectGitId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refresh Test Suite Collection list of Git Test Project
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTSC(id, options) {
            return exports.TestProjectApiFp(configuration).refreshTSC(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Executes a Test Plan. Returns the build information.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        run(id, options) {
            return exports.TestProjectApiFp(configuration).run(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Test Project detail. Returns the updated Test Project detail.
         * @param {number} id
         * @param {TestProjectResource} testProjectResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update10(id, testProjectResource, options) {
            return exports.TestProjectApiFp(configuration).update10(id, testProjectResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule detail. Returns the updated schedule detail.
         * @param {number} id
         * @param {number} schedulerId
         * @param {SchedulerResource} schedulerResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update9(id, schedulerId, schedulerResource, options) {
            return exports.TestProjectApiFp(configuration).update9(id, schedulerId, schedulerResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
         * @param {GitRepositoryResource} gitRepositoryResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitRepo(gitRepositoryResource, options) {
            return exports.TestProjectApiFp(configuration).updateGitRepo(gitRepositoryResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a Test Project package. Returns the updated Test Project detail.
         * @param {number} id
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePackage(id, batch, folderPath, fileName, uploadedPath, options) {
            return exports.TestProjectApiFp(configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new Test Project. Returns the created Test Project.
         * @param {string} name
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [description]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options) {
            return exports.TestProjectApiFp(configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestProjectApi - object-oriented interface
 * @export
 * @class TestProjectApi
 * @extends {BaseAPI}
 */
class TestProjectApi extends base_1.BaseAPI {
    /**
     *
     * @summary Creates a new schedule for a Test Plan. Returns the created schedule detail.
     * @param {number} id
     * @param {SchedulerResource} schedulerResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    create6(id, schedulerResource, options) {
        return exports.TestProjectApiFp(this.configuration).create6(id, schedulerResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a Git Test Project. Returns the Git Test Project detail.
     * @param {GitRepositoryResource} gitRepositoryResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    createGitRepo(gitRepositoryResource, options) {
        return exports.TestProjectApiFp(this.configuration).createGitRepo(gitRepositoryResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new sample Test Project. Returns the created Test Project.
     * @param {string} name
     * @param {'KS' | 'GIT'} type
     * @param {number} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    createSample(name, type, projectId, options) {
        return exports.TestProjectApiFp(this.configuration).createSample(name, type, projectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a Test Project. Returns the deleted Test Project.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    delete6(id, options) {
        return exports.TestProjectApiFp(this.configuration).delete6(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule. Returns the deleted schedule detail.
     * @param {number} id
     * @param {number} schedulerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    delete7(id, schedulerId, options) {
        return exports.TestProjectApiFp(this.configuration).delete7(id, schedulerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads a Test Project package. Returns the latest Test Project package file.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    download4(id, options) {
        return exports.TestProjectApiFp(this.configuration).download4(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Test Project detail.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    get17(id, options) {
        return exports.TestProjectApiFp(this.configuration).get17(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a schedule detail.
     * @param {number} id
     * @param {number} schedulerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    getScheduler(id, schedulerId, options) {
        return exports.TestProjectApiFp(this.configuration).getScheduler(id, schedulerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a Git Test Project detail.
     * @param {number} testProjectGitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    getTestProjectGit(testProjectGitId, options) {
        return exports.TestProjectApiFp(this.configuration).getTestProjectGit(testProjectGitId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refresh Test Suite Collection list of Git Test Project
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    refreshTSC(id, options) {
        return exports.TestProjectApiFp(this.configuration).refreshTSC(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Executes a Test Plan. Returns the build information.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    run(id, options) {
        return exports.TestProjectApiFp(this.configuration).run(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Test Project detail. Returns the updated Test Project detail.
     * @param {number} id
     * @param {TestProjectResource} testProjectResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    update10(id, testProjectResource, options) {
        return exports.TestProjectApiFp(this.configuration).update10(id, testProjectResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a schedule detail. Returns the updated schedule detail.
     * @param {number} id
     * @param {number} schedulerId
     * @param {SchedulerResource} schedulerResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    update9(id, schedulerId, schedulerResource, options) {
        return exports.TestProjectApiFp(this.configuration).update9(id, schedulerId, schedulerResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a Git Test Project detail. Returns the updated Git Test Project detail.
     * @param {GitRepositoryResource} gitRepositoryResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    updateGitRepo(gitRepositoryResource, options) {
        return exports.TestProjectApiFp(this.configuration).updateGitRepo(gitRepositoryResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a Test Project package. Returns the updated Test Project detail.
     * @param {number} id
     * @param {string} batch
     * @param {string} folderPath
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    updatePackage(id, batch, folderPath, fileName, uploadedPath, options) {
        return exports.TestProjectApiFp(this.configuration).updatePackage(id, batch, folderPath, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new Test Project. Returns the created Test Project.
     * @param {string} name
     * @param {string} projectId
     * @param {string} batch
     * @param {string} folderPath
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {string} [description]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestProjectApi
     */
    upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options) {
        return exports.TestProjectApiFp(this.configuration).upload1(name, projectId, batch, folderPath, fileName, uploadedPath, description, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestProjectApi = TestProjectApi;
/**
 * TestReportApi - axios parameter creator
 * @export
 */
exports.TestReportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMultipleS3File: (projectId, batch, uploadBatchFileResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling processMultipleS3File.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling processMultipleS3File.');
            }
            // verify required parameter 'uploadBatchFileResource' is not null or undefined
            if (uploadBatchFileResource === null || uploadBatchFileResource === undefined) {
                throw new base_1.RequiredError('uploadBatchFileResource', 'Required parameter uploadBatchFileResource was null or undefined when calling processMultipleS3File.');
            }
            const localVarPath = `/api/v1/katalon/test-reports/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof uploadBatchFileResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(uploadBatchFileResource !== undefined ? uploadBatchFileResource : {})
                : (uploadBatchFileResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processS3File: (projectId, batch, folderPath, isEnd, fileName, uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling processS3File.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling processS3File.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new base_1.RequiredError('folderPath', 'Required parameter folderPath was null or undefined when calling processS3File.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new base_1.RequiredError('isEnd', 'Required parameter isEnd was null or undefined when calling processS3File.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling processS3File.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling processS3File.');
            }
            const localVarPath = `/api/v1/katalon/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }
            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTestOpsReports: (projectId, batch, uploadBatchFileResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling processTestOpsReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling processTestOpsReports.');
            }
            // verify required parameter 'uploadBatchFileResource' is not null or undefined
            if (uploadBatchFileResource === null || uploadBatchFileResource === undefined) {
                throw new base_1.RequiredError('uploadBatchFileResource', 'Required parameter uploadBatchFileResource was null or undefined when calling processTestOpsReports.');
            }
            const localVarPath = `/api/v1/testops-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof uploadBatchFileResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(uploadBatchFileResource !== undefined ? uploadBatchFileResource : {})
                : (uploadBatchFileResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} projectId
         * @param {TestRunResult} testRunResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult: (projectId, testRunResult, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateResult.');
            }
            // verify required parameter 'testRunResult' is not null or undefined
            if (testRunResult === null || testRunResult === undefined) {
                throw new base_1.RequiredError('testRunResult', 'Required parameter testRunResult was null or undefined when calling updateResult.');
            }
            const localVarPath = `/api/v1/katalon/test-reports/update-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof testRunResult !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testRunResult !== undefined ? testRunResult : {})
                : (testRunResult || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [sessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadJUnitReports: (projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new base_1.RequiredError('folderPath', 'Required parameter folderPath was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new base_1.RequiredError('isEnd', 'Required parameter isEnd was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling uploadJUnitReports.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling uploadJUnitReports.');
            }
            const localVarPath = `/api/v1/junit/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }
            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId
         * @param {number} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {boolean} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTestNGReports: (executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'executionId' is not null or undefined
            if (executionId === null || executionId === undefined) {
                throw new base_1.RequiredError('executionId', 'Required parameter executionId was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new base_1.RequiredError('projectId', 'Required parameter projectId was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'batch' is not null or undefined
            if (batch === null || batch === undefined) {
                throw new base_1.RequiredError('batch', 'Required parameter batch was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'folderPath' is not null or undefined
            if (folderPath === null || folderPath === undefined) {
                throw new base_1.RequiredError('folderPath', 'Required parameter folderPath was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'isEnd' is not null or undefined
            if (isEnd === null || isEnd === undefined) {
                throw new base_1.RequiredError('isEnd', 'Required parameter isEnd was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new base_1.RequiredError('fileName', 'Required parameter fileName was null or undefined when calling uploadTestNGReports.');
            }
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling uploadTestNGReports.');
            }
            const localVarPath = `/api/v1/testng/test-reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }
            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }
            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }
            if (folderPath !== undefined) {
                localVarQueryParameter['folderPath'] = folderPath;
            }
            if (isEnd !== undefined) {
                localVarQueryParameter['isEnd'] = isEnd;
            }
            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestReportApi - functional programming interface
 * @export
 */
exports.TestReportApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMultipleS3File(projectId, batch, uploadBatchFileResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTestOpsReports(projectId, batch, uploadBatchFileResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} projectId
         * @param {TestRunResult} testRunResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult(projectId, testRunResult, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).updateResult(projectId, testRunResult, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [sessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId
         * @param {number} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {boolean} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestReportApiAxiosParamCreator(configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestReportApi - factory interface
 * @export
 */
exports.TestReportApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Saves and processes multiple uploaded Katalon reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMultipleS3File(projectId, batch, uploadBatchFileResource, options) {
            return exports.TestReportApiFp(configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Saves and processes the uploaded Katalon reports.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
            return exports.TestReportApiFp(configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Saves and processes multiple uploaded TestOps reports.
         * @param {number} projectId
         * @param {string} batch
         * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processTestOpsReports(projectId, batch, uploadBatchFileResource, options) {
            return exports.TestReportApiFp(configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} projectId
         * @param {TestRunResult} testRunResult
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResult(projectId, testRunResult, options) {
            return exports.TestReportApiFp(configuration).updateResult(projectId, testRunResult, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Uploads and processes the JUnit reports to an Execution.
         * @param {string} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {string} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {string} [sessionId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options) {
            return exports.TestReportApiFp(configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Uploads and processes the TestNG reports to an execution.
         * @param {number} executionId
         * @param {number} projectId
         * @param {string} batch
         * @param {string} folderPath
         * @param {boolean} isEnd
         * @param {string} fileName
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
            return exports.TestReportApiFp(configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestReportApi - object-oriented interface
 * @export
 * @class TestReportApi
 * @extends {BaseAPI}
 */
class TestReportApi extends base_1.BaseAPI {
    /**
     *
     * @summary Saves and processes multiple uploaded Katalon reports.
     * @param {number} projectId
     * @param {string} batch
     * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    processMultipleS3File(projectId, batch, uploadBatchFileResource, options) {
        return exports.TestReportApiFp(this.configuration).processMultipleS3File(projectId, batch, uploadBatchFileResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Saves and processes the uploaded Katalon reports.
     * @param {string} projectId
     * @param {string} batch
     * @param {string} folderPath
     * @param {string} isEnd
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
        return exports.TestReportApiFp(this.configuration).processS3File(projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Saves and processes multiple uploaded TestOps reports.
     * @param {number} projectId
     * @param {string} batch
     * @param {Array<UploadBatchFileResource>} uploadBatchFileResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    processTestOpsReports(projectId, batch, uploadBatchFileResource, options) {
        return exports.TestReportApiFp(this.configuration).processTestOpsReports(projectId, batch, uploadBatchFileResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} projectId
     * @param {TestRunResult} testRunResult
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    updateResult(projectId, testRunResult, options) {
        return exports.TestReportApiFp(this.configuration).updateResult(projectId, testRunResult, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Uploads and processes the JUnit reports to an Execution.
     * @param {string} projectId
     * @param {string} batch
     * @param {string} folderPath
     * @param {string} isEnd
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {string} [sessionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options) {
        return exports.TestReportApiFp(this.configuration).uploadJUnitReports(projectId, batch, folderPath, isEnd, fileName, uploadedPath, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Uploads and processes the TestNG reports to an execution.
     * @param {number} executionId
     * @param {number} projectId
     * @param {string} batch
     * @param {string} folderPath
     * @param {boolean} isEnd
     * @param {string} fileName
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestReportApi
     */
    uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options) {
        return exports.TestReportApiFp(this.configuration).uploadTestNGReports(executionId, projectId, batch, folderPath, isEnd, fileName, uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestReportApi = TestReportApi;
/**
 * TestSuiteApi - axios parameter creator
 * @export
 */
exports.TestSuiteApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get9: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get9.');
            }
            const localVarPath = `/api/v1/test-suites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TestSuiteApi - functional programming interface
 * @export
 */
exports.TestSuiteApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get9(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TestSuiteApiAxiosParamCreator(configuration).get9(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TestSuiteApi - factory interface
 * @export
 */
exports.TestSuiteApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns a Test Suite detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get9(id, options) {
            return exports.TestSuiteApiFp(configuration).get9(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestSuiteApi - object-oriented interface
 * @export
 * @class TestSuiteApi
 * @extends {BaseAPI}
 */
class TestSuiteApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns a Test Suite detail.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestSuiteApi
     */
    get9(id, options) {
        return exports.TestSuiteApiFp(this.configuration).get9(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestSuiteApi = TestSuiteApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
exports.UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId
         * @param {Array<number>} newUserIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserTeam: (teamId, newUserIds, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new base_1.RequiredError('teamId', 'Required parameter teamId was null or undefined when calling assignUserTeam.');
            }
            // verify required parameter 'newUserIds' is not null or undefined
            if (newUserIds === null || newUserIds === undefined) {
                throw new base_1.RequiredError('newUserIds', 'Required parameter newUserIds was null or undefined when calling assignUserTeam.');
            }
            const localVarPath = `/api/v1/users/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }
            if (newUserIds) {
                localVarQueryParameter['newUserIds'] = newUserIds;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAvatar: (uploadedPath, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'uploadedPath' is not null or undefined
            if (uploadedPath === null || uploadedPath === undefined) {
                throw new base_1.RequiredError('uploadedPath', 'Required parameter uploadedPath was null or undefined when calling changeAvatar.');
            }
            const localVarPath = `/api/v1/users/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (uploadedPath !== undefined) {
                localVarQueryParameter['uploadedPath'] = uploadedPath;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Change name for current user.
         * @param {string} firstName
         * @param {string} lastName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeName: (firstName, lastName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'firstName' is not null or undefined
            if (firstName === null || firstName === undefined) {
                throw new base_1.RequiredError('firstName', 'Required parameter firstName was null or undefined when calling changeName.');
            }
            // verify required parameter 'lastName' is not null or undefined
            if (lastName === null || lastName === undefined) {
                throw new base_1.RequiredError('lastName', 'Required parameter lastName was null or undefined when calling changeName.');
            }
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }
            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate2: (userSettingResource, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userSettingResource' is not null or undefined
            if (userSettingResource === null || userSettingResource === undefined) {
                throw new base_1.RequiredError('userSettingResource', 'Required parameter userSettingResource was null or undefined when calling createOrUpdate2.');
            }
            const localVarPath = `/api/v1/user-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const nonString = typeof userSettingResource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(userSettingResource !== undefined ? userSettingResource : {})
                : (userSettingResource || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAvatar: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/users/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get10: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/user-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: (teamId, userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new base_1.RequiredError('teamId', 'Required parameter teamId was null or undefined when calling removeUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling removeUser.');
            }
            const localVarPath = `/api/v1/users/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId
         * @param {Array<number>} newUserIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserTeam(teamId, newUserIds, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).assignUserTeam(teamId, newUserIds, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAvatar(uploadedPath, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).changeAvatar(uploadedPath, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Change name for current user.
         * @param {string} firstName
         * @param {string} lastName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeName(firstName, lastName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).changeName(firstName, lastName, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate2(userSettingResource, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).createOrUpdate2(userSettingResource, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAvatar(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).downloadAvatar(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get10(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).get10(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).getMe(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(teamId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UserApiAxiosParamCreator(configuration).removeUser(teamId, userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Adds users to a Team. Returns the added User detail.
         * @param {number} teamId
         * @param {Array<number>} newUserIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserTeam(teamId, newUserIds, options) {
            return exports.UserApiFp(configuration).assignUserTeam(teamId, newUserIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change the avatar of the current User. Returns the updated User detail.
         * @param {string} uploadedPath
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAvatar(uploadedPath, options) {
            return exports.UserApiFp(configuration).changeAvatar(uploadedPath, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change name for current user.
         * @param {string} firstName
         * @param {string} lastName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeName(firstName, lastName, options) {
            return exports.UserApiFp(configuration).changeName(firstName, lastName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates the User Settings detail. Returns the updated User Settings detail.
         * @param {UserSettingResource} userSettingResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdate2(userSettingResource, options) {
            return exports.UserApiFp(configuration).createOrUpdate2(userSettingResource, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Downloads the avatar of the current User. Returns the current avatar file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAvatar(options) {
            return exports.UserApiFp(configuration).downloadAvatar(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the User Settings detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get10(options) {
            return exports.UserApiFp(configuration).get10(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the current User detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return exports.UserApiFp(configuration).getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * The user issuing this request must be the Admin of the team.
         * @summary Removes a User from a Team. Returns the removed User detail.
         * @param {number} teamId
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(teamId, userId, options) {
            return exports.UserApiFp(configuration).removeUser(teamId, userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Adds users to a Team. Returns the added User detail.
     * @param {number} teamId
     * @param {Array<number>} newUserIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    assignUserTeam(teamId, newUserIds, options) {
        return exports.UserApiFp(this.configuration).assignUserTeam(teamId, newUserIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Change the avatar of the current User. Returns the updated User detail.
     * @param {string} uploadedPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeAvatar(uploadedPath, options) {
        return exports.UserApiFp(this.configuration).changeAvatar(uploadedPath, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Change name for current user.
     * @param {string} firstName
     * @param {string} lastName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changeName(firstName, lastName, options) {
        return exports.UserApiFp(this.configuration).changeName(firstName, lastName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates the User Settings detail. Returns the updated User Settings detail.
     * @param {UserSettingResource} userSettingResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createOrUpdate2(userSettingResource, options) {
        return exports.UserApiFp(this.configuration).createOrUpdate2(userSettingResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Downloads the avatar of the current User. Returns the current avatar file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    downloadAvatar(options) {
        return exports.UserApiFp(this.configuration).downloadAvatar(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the User Settings detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    get10(options) {
        return exports.UserApiFp(this.configuration).get10(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the current User detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return exports.UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The user issuing this request must be the Admin of the team.
     * @summary Removes a User from a Team. Returns the removed User detail.
     * @param {number} teamId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    removeUser(teamId, userId, options) {
        return exports.UserApiFp(this.configuration).removeUser(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
/**
 * WebServiceApi - axios parameter creator
 * @export
 */
exports.WebServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Web Service detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get16: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling get16.');
            }
            const localVarPath = `/api/v1/test-objects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WebServiceApi - functional programming interface
 * @export
 */
exports.WebServiceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns a Web Service detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get16(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.WebServiceApiAxiosParamCreator(configuration).get16(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * WebServiceApi - factory interface
 * @export
 */
exports.WebServiceApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns a Web Service detail.
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get16(id, options) {
            return exports.WebServiceApiFp(configuration).get16(id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WebServiceApi - object-oriented interface
 * @export
 * @class WebServiceApi
 * @extends {BaseAPI}
 */
class WebServiceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Returns a Web Service detail.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebServiceApi
     */
    get16(id, options) {
        return exports.WebServiceApiFp(this.configuration).get16(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebServiceApi = WebServiceApi;
